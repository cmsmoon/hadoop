/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.apache.hadoop.thriftfs.api;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class Namenode {

  /**
   * Provides an interface to a Hadoop Namenode. It is basically a Thrift
   * translation of org.apache.hadoop.hdfs.protocol.ClientProtocol.
   */
  public interface Iface {

    /**
     * Set permissions of an existing file or directory.
     * 
     * @param path Path of the file or directory.
     * 
     * @param perms New permissions for the file or directory.
     */
    public void chmod(String path, short perms) throws IOException, TException;

    /**
     * Set owner of a file or directory.
     * 
     * If either parameter 'owner' or 'group' is set to null, that
     * parameter is left unchanged.
     * 
     * Parameters 'owner' and 'group' cannot be both null.
     * 
     * @param path Path to the file or directory
     * 
     * @param owner New owner.
     * 
     * @param group New group.
     */
    public void chown(String path, String owner, String group) throws IOException, TException;

    /**
     * Return a list containing:
     *   (index 0) The total storage capacity of the file system (in bytes).
     *   (index 1) The total used space of the file system (in bytes).
     *   (index 2) The available storage of the file system (in bytes).
     */
    public List<Long> df() throws IOException, TException;

    /**
     * Enter safe mode.
     */
    public void enterSafeMode() throws IOException, TException;

    /**
     * Get a list of all blocks containing a region of a file
     * 
     * @param path Path to the file.
     * 
     * @param offset Offset of the region.
     * 
     * @param length Length of the region
     */
    public List<Block> getBlocks(String path, long offset, long length) throws IOException, TException;

    /**
     * Get a report on the system's current data nodes.
     * 
     * @param type Type of data nodes to return
     * information about.
     */
    public List<DatanodeInfo> getDatanodeReport(int type) throws IOException, TException;

    /**
     * Get the preferred block size for the given file.
     * 
     * The path must exist, or IOException is thrown.
     * 
     * @param path Path to the file.
     */
    public long getPreferredBlockSize(String path) throws IOException, TException;

    /**
     * Returns whether HDFS is in safe mode or not.
     */
    public boolean isInSafeMode() throws IOException, TException;

    /**
     * Leave safe mode.
     */
    public void leaveSafeMode() throws IOException, TException;

    /**
     * Get a listing of the indicated directory.
     * 
     * @param path Path to the directory.
     */
    public List<Stat> ls(String path) throws IOException, TException;

    /**
     * Create a directory (or hierarchy of directories).
     * 
     * Returns false if directory did not exist and could not be created,
     * true otherwise.
     * 
     * @param path Path to the directory.
     * 
     * @param perms Access permissions of the directory.
     */
    public boolean mkdirhier(String path, short perms) throws IOException, TException;

    /**
     * Tells the name node to reread the hosts and exclude files.
     */
    public void refreshNodes() throws IOException, TException;

    /**
     * Rename an item in the file system namespace.
     * 
     * Returns true  if successful, or
     *         false if the old name does not exist or if the new name already
     *               belongs to the namespace.
     * 
     * @param path Path to existing file or directory.
     * 
     * @param newPath New path.
     */
    public boolean rename(String path, String newPath) throws IOException, TException;

    /**
     * Report corrupted blocks.
     * 
     * @param blocks List of corrupted blocks.
     */
    public void reportBadBlocks(List<Block> blocks) throws IOException, TException;

    /**
     * Get information about a path in HDFS.
     * 
     * Return value will be nul if path does not exist.
     * 
     * @param path Path of the file or directory.
     */
    public Stat stat(String path) throws IOException, TException;

    /**
     * Set the quota for a directory.
     * 
     * Quota parameters may have three types of values:
     * 
     *    (1) 0 or more:      Quota will be set to that value.
     *    (2) QUOTA_DONT_SET: Quota will not be changed,
     *    (3) QUOTA_RESET:    Quota will be reset.
     * 
     * Any other value is a runtime error.
     * 
     * @param path Path of the directory.
     * 
     * @param namespaceQuota Limit on the number of names in the directory.
     * 
     * @param diskspaceQuota Limit on disk space occupied by all the files in the
     * directory.
     */
    public void setQuota(String path, long namespaceQuota, long diskspaceQuota) throws IOException, TException;

    /**
     * Set replication factor for an existing file.
     * 
     * This call just updates the value of the replication factor. The actual
     * block replication is not expected to be performed during this method call.
     * The blocks will be populated or removed in the background as the result of
     * the routine block maintenance procedures.
     * 
     * Returns true if successful, false if file does not exist or is a
     * directory.
     * 
     * @param path Path of the file.
     * 
     * @param replication New replication factor.
     */
    public boolean setReplication(String path, short replication) throws IOException, TException;

    /**
     * Delete a file or directory from the file system.
     * 
     * Any blocks belonging to the deleted files will be garbage-collected.
     * 
     * @param path Path of the file or directory.
     * 
     * @param recursive Delete a non-empty directory recursively.
     */
    public boolean unlink(String path, boolean recursive) throws IOException, TException;

    /**
     * Sets the modification and access time of a file or directory.
     * 
     * Setting *one single time paramater* to -1 means that time parameter
     * must not be set by this call.
     * 
     * Setting *both time parameters* to -1 means both of them must be set to
     * the current time.
     * 
     * @param path Path of the file or directory.
     * 
     * @param atime Access time in milliseconds since 1970-01-01 00:00 UTC
     * 
     * @param mtime Modification time in milliseconds since 1970-01-01 00:00 UTC
     */
    public void utime(String path, long atime, long mtime) throws IOException, TException;

    /**
     * Inform the namenode that a datanode process has started.
     * 
     * @param name <host name>:<port number> of the datanode
     * 
     * @param thriftPort Thrift port of the datanode
     */
    public void datanodeUp(String name, int thriftPort) throws TException;

    /**
     * Inform the namenode that a datanode process has stopped.
     * 
     * @param name <host name>:<port number> of the datanode
     * 
     * @param thriftPort Thrift port of the datanode
     */
    public void datanodeDown(String name, int thriftPort) throws TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void chmod(String path, short perms) throws IOException, TException
    {
      send_chmod(path, perms);
      recv_chmod();
    }

    public void send_chmod(String path, short perms) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("chmod", TMessageType.CALL, seqid_));
      chmod_args args = new chmod_args();
      args.path = path;
      args.perms = perms;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_chmod() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      chmod_result result = new chmod_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public void chown(String path, String owner, String group) throws IOException, TException
    {
      send_chown(path, owner, group);
      recv_chown();
    }

    public void send_chown(String path, String owner, String group) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("chown", TMessageType.CALL, seqid_));
      chown_args args = new chown_args();
      args.path = path;
      args.owner = owner;
      args.group = group;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_chown() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      chown_result result = new chown_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public List<Long> df() throws IOException, TException
    {
      send_df();
      return recv_df();
    }

    public void send_df() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("df", TMessageType.CALL, seqid_));
      df_args args = new df_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Long> recv_df() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      df_result result = new df_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "df failed: unknown result");
    }

    public void enterSafeMode() throws IOException, TException
    {
      send_enterSafeMode();
      recv_enterSafeMode();
    }

    public void send_enterSafeMode() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enterSafeMode", TMessageType.CALL, seqid_));
      enterSafeMode_args args = new enterSafeMode_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enterSafeMode() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      enterSafeMode_result result = new enterSafeMode_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public List<Block> getBlocks(String path, long offset, long length) throws IOException, TException
    {
      send_getBlocks(path, offset, length);
      return recv_getBlocks();
    }

    public void send_getBlocks(String path, long offset, long length) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getBlocks", TMessageType.CALL, seqid_));
      getBlocks_args args = new getBlocks_args();
      args.path = path;
      args.offset = offset;
      args.length = length;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Block> recv_getBlocks() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getBlocks_result result = new getBlocks_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getBlocks failed: unknown result");
    }

    public List<DatanodeInfo> getDatanodeReport(int type) throws IOException, TException
    {
      send_getDatanodeReport(type);
      return recv_getDatanodeReport();
    }

    public void send_getDatanodeReport(int type) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getDatanodeReport", TMessageType.CALL, seqid_));
      getDatanodeReport_args args = new getDatanodeReport_args();
      args.type = type;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<DatanodeInfo> recv_getDatanodeReport() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getDatanodeReport_result result = new getDatanodeReport_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getDatanodeReport failed: unknown result");
    }

    public long getPreferredBlockSize(String path) throws IOException, TException
    {
      send_getPreferredBlockSize(path);
      return recv_getPreferredBlockSize();
    }

    public void send_getPreferredBlockSize(String path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getPreferredBlockSize", TMessageType.CALL, seqid_));
      getPreferredBlockSize_args args = new getPreferredBlockSize_args();
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_getPreferredBlockSize() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getPreferredBlockSize_result result = new getPreferredBlockSize_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getPreferredBlockSize failed: unknown result");
    }

    public boolean isInSafeMode() throws IOException, TException
    {
      send_isInSafeMode();
      return recv_isInSafeMode();
    }

    public void send_isInSafeMode() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("isInSafeMode", TMessageType.CALL, seqid_));
      isInSafeMode_args args = new isInSafeMode_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_isInSafeMode() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      isInSafeMode_result result = new isInSafeMode_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "isInSafeMode failed: unknown result");
    }

    public void leaveSafeMode() throws IOException, TException
    {
      send_leaveSafeMode();
      recv_leaveSafeMode();
    }

    public void send_leaveSafeMode() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("leaveSafeMode", TMessageType.CALL, seqid_));
      leaveSafeMode_args args = new leaveSafeMode_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_leaveSafeMode() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      leaveSafeMode_result result = new leaveSafeMode_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public List<Stat> ls(String path) throws IOException, TException
    {
      send_ls(path);
      return recv_ls();
    }

    public void send_ls(String path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("ls", TMessageType.CALL, seqid_));
      ls_args args = new ls_args();
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Stat> recv_ls() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      ls_result result = new ls_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "ls failed: unknown result");
    }

    public boolean mkdirhier(String path, short perms) throws IOException, TException
    {
      send_mkdirhier(path, perms);
      return recv_mkdirhier();
    }

    public void send_mkdirhier(String path, short perms) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("mkdirhier", TMessageType.CALL, seqid_));
      mkdirhier_args args = new mkdirhier_args();
      args.path = path;
      args.perms = perms;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_mkdirhier() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      mkdirhier_result result = new mkdirhier_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "mkdirhier failed: unknown result");
    }

    public void refreshNodes() throws IOException, TException
    {
      send_refreshNodes();
      recv_refreshNodes();
    }

    public void send_refreshNodes() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("refreshNodes", TMessageType.CALL, seqid_));
      refreshNodes_args args = new refreshNodes_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_refreshNodes() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      refreshNodes_result result = new refreshNodes_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public boolean rename(String path, String newPath) throws IOException, TException
    {
      send_rename(path, newPath);
      return recv_rename();
    }

    public void send_rename(String path, String newPath) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("rename", TMessageType.CALL, seqid_));
      rename_args args = new rename_args();
      args.path = path;
      args.newPath = newPath;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_rename() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      rename_result result = new rename_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "rename failed: unknown result");
    }

    public void reportBadBlocks(List<Block> blocks) throws IOException, TException
    {
      send_reportBadBlocks(blocks);
      recv_reportBadBlocks();
    }

    public void send_reportBadBlocks(List<Block> blocks) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("reportBadBlocks", TMessageType.CALL, seqid_));
      reportBadBlocks_args args = new reportBadBlocks_args();
      args.blocks = blocks;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_reportBadBlocks() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      reportBadBlocks_result result = new reportBadBlocks_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public Stat stat(String path) throws IOException, TException
    {
      send_stat(path);
      return recv_stat();
    }

    public void send_stat(String path) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("stat", TMessageType.CALL, seqid_));
      stat_args args = new stat_args();
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Stat recv_stat() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      stat_result result = new stat_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "stat failed: unknown result");
    }

    public void setQuota(String path, long namespaceQuota, long diskspaceQuota) throws IOException, TException
    {
      send_setQuota(path, namespaceQuota, diskspaceQuota);
      recv_setQuota();
    }

    public void send_setQuota(String path, long namespaceQuota, long diskspaceQuota) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setQuota", TMessageType.CALL, seqid_));
      setQuota_args args = new setQuota_args();
      args.path = path;
      args.namespaceQuota = namespaceQuota;
      args.diskspaceQuota = diskspaceQuota;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_setQuota() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      setQuota_result result = new setQuota_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public boolean setReplication(String path, short replication) throws IOException, TException
    {
      send_setReplication(path, replication);
      return recv_setReplication();
    }

    public void send_setReplication(String path, short replication) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setReplication", TMessageType.CALL, seqid_));
      setReplication_args args = new setReplication_args();
      args.path = path;
      args.replication = replication;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_setReplication() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      setReplication_result result = new setReplication_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "setReplication failed: unknown result");
    }

    public boolean unlink(String path, boolean recursive) throws IOException, TException
    {
      send_unlink(path, recursive);
      return recv_unlink();
    }

    public void send_unlink(String path, boolean recursive) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("unlink", TMessageType.CALL, seqid_));
      unlink_args args = new unlink_args();
      args.path = path;
      args.recursive = recursive;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_unlink() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      unlink_result result = new unlink_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "unlink failed: unknown result");
    }

    public void utime(String path, long atime, long mtime) throws IOException, TException
    {
      send_utime(path, atime, mtime);
      recv_utime();
    }

    public void send_utime(String path, long atime, long mtime) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("utime", TMessageType.CALL, seqid_));
      utime_args args = new utime_args();
      args.path = path;
      args.atime = atime;
      args.mtime = mtime;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_utime() throws IOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      utime_result result = new utime_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public void datanodeUp(String name, int thriftPort) throws TException
    {
      send_datanodeUp(name, thriftPort);
      recv_datanodeUp();
    }

    public void send_datanodeUp(String name, int thriftPort) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("datanodeUp", TMessageType.CALL, seqid_));
      datanodeUp_args args = new datanodeUp_args();
      args.name = name;
      args.thriftPort = thriftPort;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_datanodeUp() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      datanodeUp_result result = new datanodeUp_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void datanodeDown(String name, int thriftPort) throws TException
    {
      send_datanodeDown(name, thriftPort);
      recv_datanodeDown();
    }

    public void send_datanodeDown(String name, int thriftPort) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("datanodeDown", TMessageType.CALL, seqid_));
      datanodeDown_args args = new datanodeDown_args();
      args.name = name;
      args.thriftPort = thriftPort;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_datanodeDown() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      datanodeDown_result result = new datanodeDown_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

  }
  public static class Processor implements TProcessor {
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("chmod", new chmod());
      processMap_.put("chown", new chown());
      processMap_.put("df", new df());
      processMap_.put("enterSafeMode", new enterSafeMode());
      processMap_.put("getBlocks", new getBlocks());
      processMap_.put("getDatanodeReport", new getDatanodeReport());
      processMap_.put("getPreferredBlockSize", new getPreferredBlockSize());
      processMap_.put("isInSafeMode", new isInSafeMode());
      processMap_.put("leaveSafeMode", new leaveSafeMode());
      processMap_.put("ls", new ls());
      processMap_.put("mkdirhier", new mkdirhier());
      processMap_.put("refreshNodes", new refreshNodes());
      processMap_.put("rename", new rename());
      processMap_.put("reportBadBlocks", new reportBadBlocks());
      processMap_.put("stat", new stat());
      processMap_.put("setQuota", new setQuota());
      processMap_.put("setReplication", new setReplication());
      processMap_.put("unlink", new unlink());
      processMap_.put("utime", new utime());
      processMap_.put("datanodeUp", new datanodeUp());
      processMap_.put("datanodeDown", new datanodeDown());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class chmod implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        chmod_args args = new chmod_args();
        args.read(iprot);
        iprot.readMessageEnd();
        chmod_result result = new chmod_result();
        try {
          iface_.chmod(args.path, args.perms);
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("chmod", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class chown implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        chown_args args = new chown_args();
        args.read(iprot);
        iprot.readMessageEnd();
        chown_result result = new chown_result();
        try {
          iface_.chown(args.path, args.owner, args.group);
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("chown", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class df implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        df_args args = new df_args();
        args.read(iprot);
        iprot.readMessageEnd();
        df_result result = new df_result();
        try {
          result.success = iface_.df();
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("df", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class enterSafeMode implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enterSafeMode_args args = new enterSafeMode_args();
        args.read(iprot);
        iprot.readMessageEnd();
        enterSafeMode_result result = new enterSafeMode_result();
        try {
          iface_.enterSafeMode();
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("enterSafeMode", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getBlocks implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getBlocks_args args = new getBlocks_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getBlocks_result result = new getBlocks_result();
        try {
          result.success = iface_.getBlocks(args.path, args.offset, args.length);
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("getBlocks", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getDatanodeReport implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getDatanodeReport_args args = new getDatanodeReport_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getDatanodeReport_result result = new getDatanodeReport_result();
        try {
          result.success = iface_.getDatanodeReport(args.type);
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("getDatanodeReport", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getPreferredBlockSize implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getPreferredBlockSize_args args = new getPreferredBlockSize_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getPreferredBlockSize_result result = new getPreferredBlockSize_result();
        try {
          result.success = iface_.getPreferredBlockSize(args.path);
          result.__isset.success = true;
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("getPreferredBlockSize", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class isInSafeMode implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        isInSafeMode_args args = new isInSafeMode_args();
        args.read(iprot);
        iprot.readMessageEnd();
        isInSafeMode_result result = new isInSafeMode_result();
        try {
          result.success = iface_.isInSafeMode();
          result.__isset.success = true;
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("isInSafeMode", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class leaveSafeMode implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        leaveSafeMode_args args = new leaveSafeMode_args();
        args.read(iprot);
        iprot.readMessageEnd();
        leaveSafeMode_result result = new leaveSafeMode_result();
        try {
          iface_.leaveSafeMode();
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("leaveSafeMode", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class ls implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        ls_args args = new ls_args();
        args.read(iprot);
        iprot.readMessageEnd();
        ls_result result = new ls_result();
        try {
          result.success = iface_.ls(args.path);
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("ls", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class mkdirhier implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        mkdirhier_args args = new mkdirhier_args();
        args.read(iprot);
        iprot.readMessageEnd();
        mkdirhier_result result = new mkdirhier_result();
        try {
          result.success = iface_.mkdirhier(args.path, args.perms);
          result.__isset.success = true;
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("mkdirhier", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class refreshNodes implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        refreshNodes_args args = new refreshNodes_args();
        args.read(iprot);
        iprot.readMessageEnd();
        refreshNodes_result result = new refreshNodes_result();
        try {
          iface_.refreshNodes();
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("refreshNodes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class rename implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        rename_args args = new rename_args();
        args.read(iprot);
        iprot.readMessageEnd();
        rename_result result = new rename_result();
        try {
          result.success = iface_.rename(args.path, args.newPath);
          result.__isset.success = true;
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("rename", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class reportBadBlocks implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        reportBadBlocks_args args = new reportBadBlocks_args();
        args.read(iprot);
        iprot.readMessageEnd();
        reportBadBlocks_result result = new reportBadBlocks_result();
        try {
          iface_.reportBadBlocks(args.blocks);
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("reportBadBlocks", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class stat implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        stat_args args = new stat_args();
        args.read(iprot);
        iprot.readMessageEnd();
        stat_result result = new stat_result();
        try {
          result.success = iface_.stat(args.path);
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("stat", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setQuota implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setQuota_args args = new setQuota_args();
        args.read(iprot);
        iprot.readMessageEnd();
        setQuota_result result = new setQuota_result();
        try {
          iface_.setQuota(args.path, args.namespaceQuota, args.diskspaceQuota);
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("setQuota", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setReplication implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setReplication_args args = new setReplication_args();
        args.read(iprot);
        iprot.readMessageEnd();
        setReplication_result result = new setReplication_result();
        try {
          result.success = iface_.setReplication(args.path, args.replication);
          result.__isset.success = true;
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("setReplication", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class unlink implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        unlink_args args = new unlink_args();
        args.read(iprot);
        iprot.readMessageEnd();
        unlink_result result = new unlink_result();
        try {
          result.success = iface_.unlink(args.path, args.recursive);
          result.__isset.success = true;
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("unlink", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class utime implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        utime_args args = new utime_args();
        args.read(iprot);
        iprot.readMessageEnd();
        utime_result result = new utime_result();
        try {
          iface_.utime(args.path, args.atime, args.mtime);
        } catch (IOException err) {
          result.err = err;
        }
        oprot.writeMessageBegin(new TMessage("utime", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class datanodeUp implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        datanodeUp_args args = new datanodeUp_args();
        args.read(iprot);
        iprot.readMessageEnd();
        datanodeUp_result result = new datanodeUp_result();
        iface_.datanodeUp(args.name, args.thriftPort);
        oprot.writeMessageBegin(new TMessage("datanodeUp", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class datanodeDown implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        datanodeDown_args args = new datanodeDown_args();
        args.read(iprot);
        iprot.readMessageEnd();
        datanodeDown_result result = new datanodeDown_result();
        iface_.datanodeDown(args.name, args.thriftPort);
        oprot.writeMessageBegin(new TMessage("datanodeDown", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class chmod_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("chmod_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);
    private static final TField PERMS_FIELD_DESC = new TField("perms", TType.I16, (short)2);

    /**
     * Path of the file or directory.
     */
    public String path;
    public static final int PATH = 1;
    /**
     * New permissions for the file or directory.
     */
    public short perms;
    public static final int PERMS = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean perms = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(PERMS, new FieldMetaData("perms", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(chmod_args.class, metaDataMap);
    }

    public chmod_args() {
    }

    public chmod_args(
      String path,
      short perms)
    {
      this();
      this.path = path;
      this.perms = perms;
      this.__isset.perms = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public chmod_args(chmod_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
      __isset.perms = other.__isset.perms;
      this.perms = other.perms;
    }

    @Override
    public chmod_args clone() {
      return new chmod_args(this);
    }

    /**
     * Path of the file or directory.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path of the file or directory.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    /**
     * New permissions for the file or directory.
     */
    public short getPerms() {
      return this.perms;
    }

    /**
     * New permissions for the file or directory.
     */
    public void setPerms(short perms) {
      this.perms = perms;
      this.__isset.perms = true;
    }

    public void unsetPerms() {
      this.__isset.perms = false;
    }

    // Returns true if field perms is set (has been asigned a value) and false otherwise
    public boolean isSetPerms() {
      return this.__isset.perms;
    }

    public void setPermsIsSet(boolean value) {
      this.__isset.perms = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      case PERMS:
        if (value == null) {
          unsetPerms();
        } else {
          setPerms((Short)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case PERMS:
        return new Short(getPerms());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case PERMS:
        return isSetPerms();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof chmod_args)
        return this.equals((chmod_args)that);
      return false;
    }

    public boolean equals(chmod_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_perms = true;
      boolean that_present_perms = true;
      if (this_present_perms || that_present_perms) {
        if (!(this_present_perms && that_present_perms))
          return false;
        if (this.perms != that.perms)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case PERMS:
            if (field.type == TType.I16) {
              this.perms = iprot.readI16();
              this.__isset.perms = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(PERMS_FIELD_DESC);
      oprot.writeI16(this.perms);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("chmod_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("perms:");
      sb.append(this.perms);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class chmod_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("chmod_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(chmod_result.class, metaDataMap);
    }

    public chmod_result() {
    }

    public chmod_result(
      IOException err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public chmod_result(chmod_result other) {
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public chmod_result clone() {
      return new chmod_result(this);
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof chmod_result)
        return this.equals((chmod_result)that);
      return false;
    }

    public boolean equals(chmod_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("chmod_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class chown_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("chown_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);
    private static final TField OWNER_FIELD_DESC = new TField("owner", TType.STRING, (short)2);
    private static final TField GROUP_FIELD_DESC = new TField("group", TType.STRING, (short)3);

    /**
     * Path to the file or directory
     */
    public String path;
    public static final int PATH = 1;
    /**
     * New owner.
     */
    public String owner;
    public static final int OWNER = 2;
    /**
     * New group.
     */
    public String group;
    public static final int GROUP = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(OWNER, new FieldMetaData("owner", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(GROUP, new FieldMetaData("group", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(chown_args.class, metaDataMap);
    }

    public chown_args() {
    }

    public chown_args(
      String path,
      String owner,
      String group)
    {
      this();
      this.path = path;
      this.owner = owner;
      this.group = group;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public chown_args(chown_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
      if (other.isSetOwner()) {
        this.owner = other.owner;
      }
      if (other.isSetGroup()) {
        this.group = other.group;
      }
    }

    @Override
    public chown_args clone() {
      return new chown_args(this);
    }

    /**
     * Path to the file or directory
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path to the file or directory
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    /**
     * New owner.
     */
    public String getOwner() {
      return this.owner;
    }

    /**
     * New owner.
     */
    public void setOwner(String owner) {
      this.owner = owner;
    }

    public void unsetOwner() {
      this.owner = null;
    }

    // Returns true if field owner is set (has been asigned a value) and false otherwise
    public boolean isSetOwner() {
      return this.owner != null;
    }

    public void setOwnerIsSet(boolean value) {
      if (!value) {
        this.owner = null;
      }
    }

    /**
     * New group.
     */
    public String getGroup() {
      return this.group;
    }

    /**
     * New group.
     */
    public void setGroup(String group) {
      this.group = group;
    }

    public void unsetGroup() {
      this.group = null;
    }

    // Returns true if field group is set (has been asigned a value) and false otherwise
    public boolean isSetGroup() {
      return this.group != null;
    }

    public void setGroupIsSet(boolean value) {
      if (!value) {
        this.group = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      case OWNER:
        if (value == null) {
          unsetOwner();
        } else {
          setOwner((String)value);
        }
        break;

      case GROUP:
        if (value == null) {
          unsetGroup();
        } else {
          setGroup((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case OWNER:
        return getOwner();

      case GROUP:
        return getGroup();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case OWNER:
        return isSetOwner();
      case GROUP:
        return isSetGroup();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof chown_args)
        return this.equals((chown_args)that);
      return false;
    }

    public boolean equals(chown_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_owner = true && this.isSetOwner();
      boolean that_present_owner = true && that.isSetOwner();
      if (this_present_owner || that_present_owner) {
        if (!(this_present_owner && that_present_owner))
          return false;
        if (!this.owner.equals(that.owner))
          return false;
      }

      boolean this_present_group = true && this.isSetGroup();
      boolean that_present_group = true && that.isSetGroup();
      if (this_present_group || that_present_group) {
        if (!(this_present_group && that_present_group))
          return false;
        if (!this.group.equals(that.group))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OWNER:
            if (field.type == TType.STRING) {
              this.owner = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case GROUP:
            if (field.type == TType.STRING) {
              this.group = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      if (this.owner != null) {
        oprot.writeFieldBegin(OWNER_FIELD_DESC);
        oprot.writeString(this.owner);
        oprot.writeFieldEnd();
      }
      if (this.group != null) {
        oprot.writeFieldBegin(GROUP_FIELD_DESC);
        oprot.writeString(this.group);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("chown_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("owner:");
      if (this.owner == null) {
        sb.append("null");
      } else {
        sb.append(this.owner);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("group:");
      if (this.group == null) {
        sb.append("null");
      } else {
        sb.append(this.group);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class chown_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("chown_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(chown_result.class, metaDataMap);
    }

    public chown_result() {
    }

    public chown_result(
      IOException err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public chown_result(chown_result other) {
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public chown_result clone() {
      return new chown_result(this);
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof chown_result)
        return this.equals((chown_result)that);
      return false;
    }

    public boolean equals(chown_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("chown_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class df_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("df_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(df_args.class, metaDataMap);
    }

    public df_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public df_args(df_args other) {
    }

    @Override
    public df_args clone() {
      return new df_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof df_args)
        return this.equals((df_args)that);
      return false;
    }

    public boolean equals(df_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("df_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class df_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("df_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public List<Long> success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I64))));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(df_result.class, metaDataMap);
    }

    public df_result() {
    }

    public df_result(
      List<Long> success,
      IOException err)
    {
      this();
      this.success = success;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public df_result(df_result other) {
      if (other.isSetSuccess()) {
        List<Long> __this__success = new ArrayList<Long>();
        for (Long other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public df_result clone() {
      return new df_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Long> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(long elem) {
      if (this.success == null) {
        this.success = new ArrayList<Long>();
      }
      this.success.add(elem);
    }

    public List<Long> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Long> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Long>)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof df_result)
        return this.equals((df_result)that);
      return false;
    }

    public boolean equals(df_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list4 = iprot.readListBegin();
                this.success = new ArrayList<Long>(_list4.size);
                for (int _i5 = 0; _i5 < _list4.size; ++_i5)
                {
                  long _elem6;
                  _elem6 = iprot.readI64();
                  this.success.add(_elem6);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I64, this.success.size()));
          for (long _iter7 : this.success)          {
            oprot.writeI64(_iter7);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("df_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class enterSafeMode_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enterSafeMode_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(enterSafeMode_args.class, metaDataMap);
    }

    public enterSafeMode_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enterSafeMode_args(enterSafeMode_args other) {
    }

    @Override
    public enterSafeMode_args clone() {
      return new enterSafeMode_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enterSafeMode_args)
        return this.equals((enterSafeMode_args)that);
      return false;
    }

    public boolean equals(enterSafeMode_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enterSafeMode_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class enterSafeMode_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("enterSafeMode_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(enterSafeMode_result.class, metaDataMap);
    }

    public enterSafeMode_result() {
    }

    public enterSafeMode_result(
      IOException err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enterSafeMode_result(enterSafeMode_result other) {
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public enterSafeMode_result clone() {
      return new enterSafeMode_result(this);
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enterSafeMode_result)
        return this.equals((enterSafeMode_result)that);
      return false;
    }

    public boolean equals(enterSafeMode_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enterSafeMode_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getBlocks_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getBlocks_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);
    private static final TField OFFSET_FIELD_DESC = new TField("offset", TType.I64, (short)2);
    private static final TField LENGTH_FIELD_DESC = new TField("length", TType.I64, (short)3);

    /**
     * Path to the file.
     */
    public String path;
    public static final int PATH = 1;
    /**
     * Offset of the region.
     */
    public long offset;
    public static final int OFFSET = 2;
    /**
     * Length of the region
     */
    public long length;
    public static final int LENGTH = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean offset = false;
      public boolean length = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(OFFSET, new FieldMetaData("offset", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(LENGTH, new FieldMetaData("length", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getBlocks_args.class, metaDataMap);
    }

    public getBlocks_args() {
    }

    public getBlocks_args(
      String path,
      long offset,
      long length)
    {
      this();
      this.path = path;
      this.offset = offset;
      this.__isset.offset = true;
      this.length = length;
      this.__isset.length = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getBlocks_args(getBlocks_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
      __isset.offset = other.__isset.offset;
      this.offset = other.offset;
      __isset.length = other.__isset.length;
      this.length = other.length;
    }

    @Override
    public getBlocks_args clone() {
      return new getBlocks_args(this);
    }

    /**
     * Path to the file.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path to the file.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    /**
     * Offset of the region.
     */
    public long getOffset() {
      return this.offset;
    }

    /**
     * Offset of the region.
     */
    public void setOffset(long offset) {
      this.offset = offset;
      this.__isset.offset = true;
    }

    public void unsetOffset() {
      this.__isset.offset = false;
    }

    // Returns true if field offset is set (has been asigned a value) and false otherwise
    public boolean isSetOffset() {
      return this.__isset.offset;
    }

    public void setOffsetIsSet(boolean value) {
      this.__isset.offset = value;
    }

    /**
     * Length of the region
     */
    public long getLength() {
      return this.length;
    }

    /**
     * Length of the region
     */
    public void setLength(long length) {
      this.length = length;
      this.__isset.length = true;
    }

    public void unsetLength() {
      this.__isset.length = false;
    }

    // Returns true if field length is set (has been asigned a value) and false otherwise
    public boolean isSetLength() {
      return this.__isset.length;
    }

    public void setLengthIsSet(boolean value) {
      this.__isset.length = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      case OFFSET:
        if (value == null) {
          unsetOffset();
        } else {
          setOffset((Long)value);
        }
        break;

      case LENGTH:
        if (value == null) {
          unsetLength();
        } else {
          setLength((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case OFFSET:
        return new Long(getOffset());

      case LENGTH:
        return new Long(getLength());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case OFFSET:
        return isSetOffset();
      case LENGTH:
        return isSetLength();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getBlocks_args)
        return this.equals((getBlocks_args)that);
      return false;
    }

    public boolean equals(getBlocks_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_offset = true;
      boolean that_present_offset = true;
      if (this_present_offset || that_present_offset) {
        if (!(this_present_offset && that_present_offset))
          return false;
        if (this.offset != that.offset)
          return false;
      }

      boolean this_present_length = true;
      boolean that_present_length = true;
      if (this_present_length || that_present_length) {
        if (!(this_present_length && that_present_length))
          return false;
        if (this.length != that.length)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case OFFSET:
            if (field.type == TType.I64) {
              this.offset = iprot.readI64();
              this.__isset.offset = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case LENGTH:
            if (field.type == TType.I64) {
              this.length = iprot.readI64();
              this.__isset.length = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(OFFSET_FIELD_DESC);
      oprot.writeI64(this.offset);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(LENGTH_FIELD_DESC);
      oprot.writeI64(this.length);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getBlocks_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("offset:");
      sb.append(this.offset);
      first = false;
      if (!first) sb.append(", ");
      sb.append("length:");
      sb.append(this.length);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getBlocks_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getBlocks_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public List<Block> success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Block.class))));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getBlocks_result.class, metaDataMap);
    }

    public getBlocks_result() {
    }

    public getBlocks_result(
      List<Block> success,
      IOException err)
    {
      this();
      this.success = success;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getBlocks_result(getBlocks_result other) {
      if (other.isSetSuccess()) {
        List<Block> __this__success = new ArrayList<Block>();
        for (Block other_element : other.success) {
          __this__success.add(new Block(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public getBlocks_result clone() {
      return new getBlocks_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Block> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Block elem) {
      if (this.success == null) {
        this.success = new ArrayList<Block>();
      }
      this.success.add(elem);
    }

    public List<Block> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Block> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Block>)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getBlocks_result)
        return this.equals((getBlocks_result)that);
      return false;
    }

    public boolean equals(getBlocks_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list8 = iprot.readListBegin();
                this.success = new ArrayList<Block>(_list8.size);
                for (int _i9 = 0; _i9 < _list8.size; ++_i9)
                {
                  Block _elem10;
                  _elem10 = new Block();
                  _elem10.read(iprot);
                  this.success.add(_elem10);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Block _iter11 : this.success)          {
            _iter11.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getBlocks_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getDatanodeReport_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDatanodeReport_args");
    private static final TField TYPE_FIELD_DESC = new TField("type", TType.I32, (short)1);

    /**
     * Type of data nodes to return
     * information about.
     */
    public int type;
    public static final int TYPE = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean type = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TYPE, new FieldMetaData("type", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getDatanodeReport_args.class, metaDataMap);
    }

    public getDatanodeReport_args() {
    }

    public getDatanodeReport_args(
      int type)
    {
      this();
      this.type = type;
      this.__isset.type = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDatanodeReport_args(getDatanodeReport_args other) {
      __isset.type = other.__isset.type;
      this.type = other.type;
    }

    @Override
    public getDatanodeReport_args clone() {
      return new getDatanodeReport_args(this);
    }

    /**
     * Type of data nodes to return
     * information about.
     */
    public int getType() {
      return this.type;
    }

    /**
     * Type of data nodes to return
     * information about.
     */
    public void setType(int type) {
      this.type = type;
      this.__isset.type = true;
    }

    public void unsetType() {
      this.__isset.type = false;
    }

    // Returns true if field type is set (has been asigned a value) and false otherwise
    public boolean isSetType() {
      return this.__isset.type;
    }

    public void setTypeIsSet(boolean value) {
      this.__isset.type = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TYPE:
        if (value == null) {
          unsetType();
        } else {
          setType((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TYPE:
        return new Integer(getType());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TYPE:
        return isSetType();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDatanodeReport_args)
        return this.equals((getDatanodeReport_args)that);
      return false;
    }

    public boolean equals(getDatanodeReport_args that) {
      if (that == null)
        return false;

      boolean this_present_type = true;
      boolean that_present_type = true;
      if (this_present_type || that_present_type) {
        if (!(this_present_type && that_present_type))
          return false;
        if (this.type != that.type)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TYPE:
            if (field.type == TType.I32) {
              this.type = iprot.readI32();
              this.__isset.type = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(TYPE_FIELD_DESC);
      oprot.writeI32(this.type);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDatanodeReport_args(");
      boolean first = true;

      sb.append("type:");
      sb.append(this.type);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getDatanodeReport_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDatanodeReport_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public List<DatanodeInfo> success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, DatanodeInfo.class))));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getDatanodeReport_result.class, metaDataMap);
    }

    public getDatanodeReport_result() {
    }

    public getDatanodeReport_result(
      List<DatanodeInfo> success,
      IOException err)
    {
      this();
      this.success = success;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDatanodeReport_result(getDatanodeReport_result other) {
      if (other.isSetSuccess()) {
        List<DatanodeInfo> __this__success = new ArrayList<DatanodeInfo>();
        for (DatanodeInfo other_element : other.success) {
          __this__success.add(new DatanodeInfo(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public getDatanodeReport_result clone() {
      return new getDatanodeReport_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<DatanodeInfo> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(DatanodeInfo elem) {
      if (this.success == null) {
        this.success = new ArrayList<DatanodeInfo>();
      }
      this.success.add(elem);
    }

    public List<DatanodeInfo> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<DatanodeInfo> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<DatanodeInfo>)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDatanodeReport_result)
        return this.equals((getDatanodeReport_result)that);
      return false;
    }

    public boolean equals(getDatanodeReport_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list12 = iprot.readListBegin();
                this.success = new ArrayList<DatanodeInfo>(_list12.size);
                for (int _i13 = 0; _i13 < _list12.size; ++_i13)
                {
                  DatanodeInfo _elem14;
                  _elem14 = new DatanodeInfo();
                  _elem14.read(iprot);
                  this.success.add(_elem14);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (DatanodeInfo _iter15 : this.success)          {
            _iter15.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDatanodeReport_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getPreferredBlockSize_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getPreferredBlockSize_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);

    /**
     * Path to the file.
     */
    public String path;
    public static final int PATH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getPreferredBlockSize_args.class, metaDataMap);
    }

    public getPreferredBlockSize_args() {
    }

    public getPreferredBlockSize_args(
      String path)
    {
      this();
      this.path = path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPreferredBlockSize_args(getPreferredBlockSize_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
    }

    @Override
    public getPreferredBlockSize_args clone() {
      return new getPreferredBlockSize_args(this);
    }

    /**
     * Path to the file.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path to the file.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPreferredBlockSize_args)
        return this.equals((getPreferredBlockSize_args)that);
      return false;
    }

    public boolean equals(getPreferredBlockSize_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getPreferredBlockSize_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getPreferredBlockSize_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getPreferredBlockSize_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public long success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getPreferredBlockSize_result.class, metaDataMap);
    }

    public getPreferredBlockSize_result() {
    }

    public getPreferredBlockSize_result(
      long success,
      IOException err)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getPreferredBlockSize_result(getPreferredBlockSize_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public getPreferredBlockSize_result clone() {
      return new getPreferredBlockSize_result(this);
    }

    public long getSuccess() {
      return this.success;
    }

    public void setSuccess(long success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Long(getSuccess());

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getPreferredBlockSize_result)
        return this.equals((getPreferredBlockSize_result)that);
      return false;
    }

    public boolean equals(getPreferredBlockSize_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getPreferredBlockSize_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class isInSafeMode_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("isInSafeMode_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(isInSafeMode_args.class, metaDataMap);
    }

    public isInSafeMode_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public isInSafeMode_args(isInSafeMode_args other) {
    }

    @Override
    public isInSafeMode_args clone() {
      return new isInSafeMode_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof isInSafeMode_args)
        return this.equals((isInSafeMode_args)that);
      return false;
    }

    public boolean equals(isInSafeMode_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("isInSafeMode_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class isInSafeMode_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("isInSafeMode_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(isInSafeMode_result.class, metaDataMap);
    }

    public isInSafeMode_result() {
    }

    public isInSafeMode_result(
      boolean success,
      IOException err)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public isInSafeMode_result(isInSafeMode_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public isInSafeMode_result clone() {
      return new isInSafeMode_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof isInSafeMode_result)
        return this.equals((isInSafeMode_result)that);
      return false;
    }

    public boolean equals(isInSafeMode_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("isInSafeMode_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class leaveSafeMode_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("leaveSafeMode_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(leaveSafeMode_args.class, metaDataMap);
    }

    public leaveSafeMode_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public leaveSafeMode_args(leaveSafeMode_args other) {
    }

    @Override
    public leaveSafeMode_args clone() {
      return new leaveSafeMode_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof leaveSafeMode_args)
        return this.equals((leaveSafeMode_args)that);
      return false;
    }

    public boolean equals(leaveSafeMode_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("leaveSafeMode_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class leaveSafeMode_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("leaveSafeMode_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(leaveSafeMode_result.class, metaDataMap);
    }

    public leaveSafeMode_result() {
    }

    public leaveSafeMode_result(
      IOException err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public leaveSafeMode_result(leaveSafeMode_result other) {
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public leaveSafeMode_result clone() {
      return new leaveSafeMode_result(this);
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof leaveSafeMode_result)
        return this.equals((leaveSafeMode_result)that);
      return false;
    }

    public boolean equals(leaveSafeMode_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("leaveSafeMode_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class ls_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("ls_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);

    /**
     * Path to the directory.
     */
    public String path;
    public static final int PATH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(ls_args.class, metaDataMap);
    }

    public ls_args() {
    }

    public ls_args(
      String path)
    {
      this();
      this.path = path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public ls_args(ls_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
    }

    @Override
    public ls_args clone() {
      return new ls_args(this);
    }

    /**
     * Path to the directory.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path to the directory.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof ls_args)
        return this.equals((ls_args)that);
      return false;
    }

    public boolean equals(ls_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("ls_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class ls_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("ls_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public List<Stat> success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Stat.class))));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(ls_result.class, metaDataMap);
    }

    public ls_result() {
    }

    public ls_result(
      List<Stat> success,
      IOException err)
    {
      this();
      this.success = success;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public ls_result(ls_result other) {
      if (other.isSetSuccess()) {
        List<Stat> __this__success = new ArrayList<Stat>();
        for (Stat other_element : other.success) {
          __this__success.add(new Stat(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public ls_result clone() {
      return new ls_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Stat> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Stat elem) {
      if (this.success == null) {
        this.success = new ArrayList<Stat>();
      }
      this.success.add(elem);
    }

    public List<Stat> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<Stat> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Stat>)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof ls_result)
        return this.equals((ls_result)that);
      return false;
    }

    public boolean equals(ls_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list16 = iprot.readListBegin();
                this.success = new ArrayList<Stat>(_list16.size);
                for (int _i17 = 0; _i17 < _list16.size; ++_i17)
                {
                  Stat _elem18;
                  _elem18 = new Stat();
                  _elem18.read(iprot);
                  this.success.add(_elem18);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Stat _iter19 : this.success)          {
            _iter19.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("ls_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class mkdirhier_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mkdirhier_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);
    private static final TField PERMS_FIELD_DESC = new TField("perms", TType.I16, (short)2);

    /**
     * Path to the directory.
     */
    public String path;
    public static final int PATH = 1;
    /**
     * Access permissions of the directory.
     */
    public short perms;
    public static final int PERMS = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean perms = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(PERMS, new FieldMetaData("perms", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(mkdirhier_args.class, metaDataMap);
    }

    public mkdirhier_args() {
    }

    public mkdirhier_args(
      String path,
      short perms)
    {
      this();
      this.path = path;
      this.perms = perms;
      this.__isset.perms = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mkdirhier_args(mkdirhier_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
      __isset.perms = other.__isset.perms;
      this.perms = other.perms;
    }

    @Override
    public mkdirhier_args clone() {
      return new mkdirhier_args(this);
    }

    /**
     * Path to the directory.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path to the directory.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    /**
     * Access permissions of the directory.
     */
    public short getPerms() {
      return this.perms;
    }

    /**
     * Access permissions of the directory.
     */
    public void setPerms(short perms) {
      this.perms = perms;
      this.__isset.perms = true;
    }

    public void unsetPerms() {
      this.__isset.perms = false;
    }

    // Returns true if field perms is set (has been asigned a value) and false otherwise
    public boolean isSetPerms() {
      return this.__isset.perms;
    }

    public void setPermsIsSet(boolean value) {
      this.__isset.perms = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      case PERMS:
        if (value == null) {
          unsetPerms();
        } else {
          setPerms((Short)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case PERMS:
        return new Short(getPerms());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case PERMS:
        return isSetPerms();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mkdirhier_args)
        return this.equals((mkdirhier_args)that);
      return false;
    }

    public boolean equals(mkdirhier_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_perms = true;
      boolean that_present_perms = true;
      if (this_present_perms || that_present_perms) {
        if (!(this_present_perms && that_present_perms))
          return false;
        if (this.perms != that.perms)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case PERMS:
            if (field.type == TType.I16) {
              this.perms = iprot.readI16();
              this.__isset.perms = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(PERMS_FIELD_DESC);
      oprot.writeI16(this.perms);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mkdirhier_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("perms:");
      sb.append(this.perms);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class mkdirhier_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("mkdirhier_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(mkdirhier_result.class, metaDataMap);
    }

    public mkdirhier_result() {
    }

    public mkdirhier_result(
      boolean success,
      IOException err)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mkdirhier_result(mkdirhier_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public mkdirhier_result clone() {
      return new mkdirhier_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mkdirhier_result)
        return this.equals((mkdirhier_result)that);
      return false;
    }

    public boolean equals(mkdirhier_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mkdirhier_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class refreshNodes_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("refreshNodes_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(refreshNodes_args.class, metaDataMap);
    }

    public refreshNodes_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public refreshNodes_args(refreshNodes_args other) {
    }

    @Override
    public refreshNodes_args clone() {
      return new refreshNodes_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof refreshNodes_args)
        return this.equals((refreshNodes_args)that);
      return false;
    }

    public boolean equals(refreshNodes_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("refreshNodes_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class refreshNodes_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("refreshNodes_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(refreshNodes_result.class, metaDataMap);
    }

    public refreshNodes_result() {
    }

    public refreshNodes_result(
      IOException err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public refreshNodes_result(refreshNodes_result other) {
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public refreshNodes_result clone() {
      return new refreshNodes_result(this);
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof refreshNodes_result)
        return this.equals((refreshNodes_result)that);
      return false;
    }

    public boolean equals(refreshNodes_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("refreshNodes_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class rename_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("rename_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);
    private static final TField NEW_PATH_FIELD_DESC = new TField("newPath", TType.STRING, (short)2);

    /**
     * Path to existing file or directory.
     */
    public String path;
    public static final int PATH = 1;
    /**
     * New path.
     */
    public String newPath;
    public static final int NEWPATH = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(NEWPATH, new FieldMetaData("newPath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(rename_args.class, metaDataMap);
    }

    public rename_args() {
    }

    public rename_args(
      String path,
      String newPath)
    {
      this();
      this.path = path;
      this.newPath = newPath;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rename_args(rename_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
      if (other.isSetNewPath()) {
        this.newPath = other.newPath;
      }
    }

    @Override
    public rename_args clone() {
      return new rename_args(this);
    }

    /**
     * Path to existing file or directory.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path to existing file or directory.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    /**
     * New path.
     */
    public String getNewPath() {
      return this.newPath;
    }

    /**
     * New path.
     */
    public void setNewPath(String newPath) {
      this.newPath = newPath;
    }

    public void unsetNewPath() {
      this.newPath = null;
    }

    // Returns true if field newPath is set (has been asigned a value) and false otherwise
    public boolean isSetNewPath() {
      return this.newPath != null;
    }

    public void setNewPathIsSet(boolean value) {
      if (!value) {
        this.newPath = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      case NEWPATH:
        if (value == null) {
          unsetNewPath();
        } else {
          setNewPath((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case NEWPATH:
        return getNewPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case NEWPATH:
        return isSetNewPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rename_args)
        return this.equals((rename_args)that);
      return false;
    }

    public boolean equals(rename_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_newPath = true && this.isSetNewPath();
      boolean that_present_newPath = true && that.isSetNewPath();
      if (this_present_newPath || that_present_newPath) {
        if (!(this_present_newPath && that_present_newPath))
          return false;
        if (!this.newPath.equals(that.newPath))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NEWPATH:
            if (field.type == TType.STRING) {
              this.newPath = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      if (this.newPath != null) {
        oprot.writeFieldBegin(NEW_PATH_FIELD_DESC);
        oprot.writeString(this.newPath);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("rename_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("newPath:");
      if (this.newPath == null) {
        sb.append("null");
      } else {
        sb.append(this.newPath);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class rename_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("rename_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(rename_result.class, metaDataMap);
    }

    public rename_result() {
    }

    public rename_result(
      boolean success,
      IOException err)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public rename_result(rename_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public rename_result clone() {
      return new rename_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof rename_result)
        return this.equals((rename_result)that);
      return false;
    }

    public boolean equals(rename_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("rename_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class reportBadBlocks_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("reportBadBlocks_args");
    private static final TField BLOCKS_FIELD_DESC = new TField("blocks", TType.LIST, (short)1);

    /**
     * List of corrupted blocks.
     */
    public List<Block> blocks;
    public static final int BLOCKS = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BLOCKS, new FieldMetaData("blocks", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Block.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(reportBadBlocks_args.class, metaDataMap);
    }

    public reportBadBlocks_args() {
    }

    public reportBadBlocks_args(
      List<Block> blocks)
    {
      this();
      this.blocks = blocks;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public reportBadBlocks_args(reportBadBlocks_args other) {
      if (other.isSetBlocks()) {
        List<Block> __this__blocks = new ArrayList<Block>();
        for (Block other_element : other.blocks) {
          __this__blocks.add(new Block(other_element));
        }
        this.blocks = __this__blocks;
      }
    }

    @Override
    public reportBadBlocks_args clone() {
      return new reportBadBlocks_args(this);
    }

    public int getBlocksSize() {
      return (this.blocks == null) ? 0 : this.blocks.size();
    }

    public java.util.Iterator<Block> getBlocksIterator() {
      return (this.blocks == null) ? null : this.blocks.iterator();
    }

    public void addToBlocks(Block elem) {
      if (this.blocks == null) {
        this.blocks = new ArrayList<Block>();
      }
      this.blocks.add(elem);
    }

    /**
     * List of corrupted blocks.
     */
    public List<Block> getBlocks() {
      return this.blocks;
    }

    /**
     * List of corrupted blocks.
     */
    public void setBlocks(List<Block> blocks) {
      this.blocks = blocks;
    }

    public void unsetBlocks() {
      this.blocks = null;
    }

    // Returns true if field blocks is set (has been asigned a value) and false otherwise
    public boolean isSetBlocks() {
      return this.blocks != null;
    }

    public void setBlocksIsSet(boolean value) {
      if (!value) {
        this.blocks = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BLOCKS:
        if (value == null) {
          unsetBlocks();
        } else {
          setBlocks((List<Block>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BLOCKS:
        return getBlocks();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BLOCKS:
        return isSetBlocks();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof reportBadBlocks_args)
        return this.equals((reportBadBlocks_args)that);
      return false;
    }

    public boolean equals(reportBadBlocks_args that) {
      if (that == null)
        return false;

      boolean this_present_blocks = true && this.isSetBlocks();
      boolean that_present_blocks = true && that.isSetBlocks();
      if (this_present_blocks || that_present_blocks) {
        if (!(this_present_blocks && that_present_blocks))
          return false;
        if (!this.blocks.equals(that.blocks))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BLOCKS:
            if (field.type == TType.LIST) {
              {
                TList _list20 = iprot.readListBegin();
                this.blocks = new ArrayList<Block>(_list20.size);
                for (int _i21 = 0; _i21 < _list20.size; ++_i21)
                {
                  Block _elem22;
                  _elem22 = new Block();
                  _elem22.read(iprot);
                  this.blocks.add(_elem22);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.blocks != null) {
        oprot.writeFieldBegin(BLOCKS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.blocks.size()));
          for (Block _iter23 : this.blocks)          {
            _iter23.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("reportBadBlocks_args(");
      boolean first = true;

      sb.append("blocks:");
      if (this.blocks == null) {
        sb.append("null");
      } else {
        sb.append(this.blocks);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class reportBadBlocks_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("reportBadBlocks_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(reportBadBlocks_result.class, metaDataMap);
    }

    public reportBadBlocks_result() {
    }

    public reportBadBlocks_result(
      IOException err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public reportBadBlocks_result(reportBadBlocks_result other) {
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public reportBadBlocks_result clone() {
      return new reportBadBlocks_result(this);
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof reportBadBlocks_result)
        return this.equals((reportBadBlocks_result)that);
      return false;
    }

    public boolean equals(reportBadBlocks_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("reportBadBlocks_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class stat_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("stat_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);

    /**
     * Path of the file or directory.
     */
    public String path;
    public static final int PATH = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(stat_args.class, metaDataMap);
    }

    public stat_args() {
    }

    public stat_args(
      String path)
    {
      this();
      this.path = path;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stat_args(stat_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
    }

    @Override
    public stat_args clone() {
      return new stat_args(this);
    }

    /**
     * Path of the file or directory.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path of the file or directory.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stat_args)
        return this.equals((stat_args)that);
      return false;
    }

    public boolean equals(stat_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("stat_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class stat_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("stat_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public Stat success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Stat.class)));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(stat_result.class, metaDataMap);
    }

    public stat_result() {
    }

    public stat_result(
      Stat success,
      IOException err)
    {
      this();
      this.success = success;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stat_result(stat_result other) {
      if (other.isSetSuccess()) {
        this.success = new Stat(other.success);
      }
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public stat_result clone() {
      return new stat_result(this);
    }

    public Stat getSuccess() {
      return this.success;
    }

    public void setSuccess(Stat success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Stat)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stat_result)
        return this.equals((stat_result)that);
      return false;
    }

    public boolean equals(stat_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new Stat();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("stat_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setQuota_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setQuota_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);
    private static final TField NAMESPACE_QUOTA_FIELD_DESC = new TField("namespaceQuota", TType.I64, (short)2);
    private static final TField DISKSPACE_QUOTA_FIELD_DESC = new TField("diskspaceQuota", TType.I64, (short)3);

    /**
     * Path of the directory.
     */
    public String path;
    public static final int PATH = 1;
    /**
     * Limit on the number of names in the directory.
     */
    public long namespaceQuota;
    public static final int NAMESPACEQUOTA = 2;
    /**
     * Limit on disk space occupied by all the files in the
     * directory.
     */
    public long diskspaceQuota;
    public static final int DISKSPACEQUOTA = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean namespaceQuota = false;
      public boolean diskspaceQuota = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(NAMESPACEQUOTA, new FieldMetaData("namespaceQuota", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(DISKSPACEQUOTA, new FieldMetaData("diskspaceQuota", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(setQuota_args.class, metaDataMap);
    }

    public setQuota_args() {
    }

    public setQuota_args(
      String path,
      long namespaceQuota,
      long diskspaceQuota)
    {
      this();
      this.path = path;
      this.namespaceQuota = namespaceQuota;
      this.__isset.namespaceQuota = true;
      this.diskspaceQuota = diskspaceQuota;
      this.__isset.diskspaceQuota = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setQuota_args(setQuota_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
      __isset.namespaceQuota = other.__isset.namespaceQuota;
      this.namespaceQuota = other.namespaceQuota;
      __isset.diskspaceQuota = other.__isset.diskspaceQuota;
      this.diskspaceQuota = other.diskspaceQuota;
    }

    @Override
    public setQuota_args clone() {
      return new setQuota_args(this);
    }

    /**
     * Path of the directory.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path of the directory.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    /**
     * Limit on the number of names in the directory.
     */
    public long getNamespaceQuota() {
      return this.namespaceQuota;
    }

    /**
     * Limit on the number of names in the directory.
     */
    public void setNamespaceQuota(long namespaceQuota) {
      this.namespaceQuota = namespaceQuota;
      this.__isset.namespaceQuota = true;
    }

    public void unsetNamespaceQuota() {
      this.__isset.namespaceQuota = false;
    }

    // Returns true if field namespaceQuota is set (has been asigned a value) and false otherwise
    public boolean isSetNamespaceQuota() {
      return this.__isset.namespaceQuota;
    }

    public void setNamespaceQuotaIsSet(boolean value) {
      this.__isset.namespaceQuota = value;
    }

    /**
     * Limit on disk space occupied by all the files in the
     * directory.
     */
    public long getDiskspaceQuota() {
      return this.diskspaceQuota;
    }

    /**
     * Limit on disk space occupied by all the files in the
     * directory.
     */
    public void setDiskspaceQuota(long diskspaceQuota) {
      this.diskspaceQuota = diskspaceQuota;
      this.__isset.diskspaceQuota = true;
    }

    public void unsetDiskspaceQuota() {
      this.__isset.diskspaceQuota = false;
    }

    // Returns true if field diskspaceQuota is set (has been asigned a value) and false otherwise
    public boolean isSetDiskspaceQuota() {
      return this.__isset.diskspaceQuota;
    }

    public void setDiskspaceQuotaIsSet(boolean value) {
      this.__isset.diskspaceQuota = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      case NAMESPACEQUOTA:
        if (value == null) {
          unsetNamespaceQuota();
        } else {
          setNamespaceQuota((Long)value);
        }
        break;

      case DISKSPACEQUOTA:
        if (value == null) {
          unsetDiskspaceQuota();
        } else {
          setDiskspaceQuota((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case NAMESPACEQUOTA:
        return new Long(getNamespaceQuota());

      case DISKSPACEQUOTA:
        return new Long(getDiskspaceQuota());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case NAMESPACEQUOTA:
        return isSetNamespaceQuota();
      case DISKSPACEQUOTA:
        return isSetDiskspaceQuota();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setQuota_args)
        return this.equals((setQuota_args)that);
      return false;
    }

    public boolean equals(setQuota_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_namespaceQuota = true;
      boolean that_present_namespaceQuota = true;
      if (this_present_namespaceQuota || that_present_namespaceQuota) {
        if (!(this_present_namespaceQuota && that_present_namespaceQuota))
          return false;
        if (this.namespaceQuota != that.namespaceQuota)
          return false;
      }

      boolean this_present_diskspaceQuota = true;
      boolean that_present_diskspaceQuota = true;
      if (this_present_diskspaceQuota || that_present_diskspaceQuota) {
        if (!(this_present_diskspaceQuota && that_present_diskspaceQuota))
          return false;
        if (this.diskspaceQuota != that.diskspaceQuota)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NAMESPACEQUOTA:
            if (field.type == TType.I64) {
              this.namespaceQuota = iprot.readI64();
              this.__isset.namespaceQuota = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case DISKSPACEQUOTA:
            if (field.type == TType.I64) {
              this.diskspaceQuota = iprot.readI64();
              this.__isset.diskspaceQuota = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(NAMESPACE_QUOTA_FIELD_DESC);
      oprot.writeI64(this.namespaceQuota);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(DISKSPACE_QUOTA_FIELD_DESC);
      oprot.writeI64(this.diskspaceQuota);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setQuota_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("namespaceQuota:");
      sb.append(this.namespaceQuota);
      first = false;
      if (!first) sb.append(", ");
      sb.append("diskspaceQuota:");
      sb.append(this.diskspaceQuota);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setQuota_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setQuota_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(setQuota_result.class, metaDataMap);
    }

    public setQuota_result() {
    }

    public setQuota_result(
      IOException err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setQuota_result(setQuota_result other) {
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public setQuota_result clone() {
      return new setQuota_result(this);
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setQuota_result)
        return this.equals((setQuota_result)that);
      return false;
    }

    public boolean equals(setQuota_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setQuota_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setReplication_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setReplication_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);
    private static final TField REPLICATION_FIELD_DESC = new TField("replication", TType.I16, (short)2);

    /**
     * Path of the file.
     */
    public String path;
    public static final int PATH = 1;
    /**
     * New replication factor.
     */
    public short replication;
    public static final int REPLICATION = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean replication = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(REPLICATION, new FieldMetaData("replication", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I16)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(setReplication_args.class, metaDataMap);
    }

    public setReplication_args() {
    }

    public setReplication_args(
      String path,
      short replication)
    {
      this();
      this.path = path;
      this.replication = replication;
      this.__isset.replication = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setReplication_args(setReplication_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
      __isset.replication = other.__isset.replication;
      this.replication = other.replication;
    }

    @Override
    public setReplication_args clone() {
      return new setReplication_args(this);
    }

    /**
     * Path of the file.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path of the file.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    /**
     * New replication factor.
     */
    public short getReplication() {
      return this.replication;
    }

    /**
     * New replication factor.
     */
    public void setReplication(short replication) {
      this.replication = replication;
      this.__isset.replication = true;
    }

    public void unsetReplication() {
      this.__isset.replication = false;
    }

    // Returns true if field replication is set (has been asigned a value) and false otherwise
    public boolean isSetReplication() {
      return this.__isset.replication;
    }

    public void setReplicationIsSet(boolean value) {
      this.__isset.replication = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      case REPLICATION:
        if (value == null) {
          unsetReplication();
        } else {
          setReplication((Short)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case REPLICATION:
        return new Short(getReplication());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case REPLICATION:
        return isSetReplication();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setReplication_args)
        return this.equals((setReplication_args)that);
      return false;
    }

    public boolean equals(setReplication_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_replication = true;
      boolean that_present_replication = true;
      if (this_present_replication || that_present_replication) {
        if (!(this_present_replication && that_present_replication))
          return false;
        if (this.replication != that.replication)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case REPLICATION:
            if (field.type == TType.I16) {
              this.replication = iprot.readI16();
              this.__isset.replication = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(REPLICATION_FIELD_DESC);
      oprot.writeI16(this.replication);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setReplication_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("replication:");
      sb.append(this.replication);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setReplication_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setReplication_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(setReplication_result.class, metaDataMap);
    }

    public setReplication_result() {
    }

    public setReplication_result(
      boolean success,
      IOException err)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setReplication_result(setReplication_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public setReplication_result clone() {
      return new setReplication_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setReplication_result)
        return this.equals((setReplication_result)that);
      return false;
    }

    public boolean equals(setReplication_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setReplication_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class unlink_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("unlink_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);
    private static final TField RECURSIVE_FIELD_DESC = new TField("recursive", TType.BOOL, (short)2);

    /**
     * Path of the file or directory.
     */
    public String path;
    public static final int PATH = 1;
    /**
     * Delete a non-empty directory recursively.
     */
    public boolean recursive;
    public static final int RECURSIVE = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean recursive = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(RECURSIVE, new FieldMetaData("recursive", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(unlink_args.class, metaDataMap);
    }

    public unlink_args() {
    }

    public unlink_args(
      String path,
      boolean recursive)
    {
      this();
      this.path = path;
      this.recursive = recursive;
      this.__isset.recursive = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public unlink_args(unlink_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
      __isset.recursive = other.__isset.recursive;
      this.recursive = other.recursive;
    }

    @Override
    public unlink_args clone() {
      return new unlink_args(this);
    }

    /**
     * Path of the file or directory.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path of the file or directory.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    /**
     * Delete a non-empty directory recursively.
     */
    public boolean isRecursive() {
      return this.recursive;
    }

    /**
     * Delete a non-empty directory recursively.
     */
    public void setRecursive(boolean recursive) {
      this.recursive = recursive;
      this.__isset.recursive = true;
    }

    public void unsetRecursive() {
      this.__isset.recursive = false;
    }

    // Returns true if field recursive is set (has been asigned a value) and false otherwise
    public boolean isSetRecursive() {
      return this.__isset.recursive;
    }

    public void setRecursiveIsSet(boolean value) {
      this.__isset.recursive = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      case RECURSIVE:
        if (value == null) {
          unsetRecursive();
        } else {
          setRecursive((Boolean)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case RECURSIVE:
        return new Boolean(isRecursive());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case RECURSIVE:
        return isSetRecursive();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof unlink_args)
        return this.equals((unlink_args)that);
      return false;
    }

    public boolean equals(unlink_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_recursive = true;
      boolean that_present_recursive = true;
      if (this_present_recursive || that_present_recursive) {
        if (!(this_present_recursive && that_present_recursive))
          return false;
        if (this.recursive != that.recursive)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case RECURSIVE:
            if (field.type == TType.BOOL) {
              this.recursive = iprot.readBool();
              this.__isset.recursive = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(RECURSIVE_FIELD_DESC);
      oprot.writeBool(this.recursive);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("unlink_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("recursive:");
      sb.append(this.recursive);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class unlink_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("unlink_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(unlink_result.class, metaDataMap);
    }

    public unlink_result() {
    }

    public unlink_result(
      boolean success,
      IOException err)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public unlink_result(unlink_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public unlink_result clone() {
      return new unlink_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof unlink_result)
        return this.equals((unlink_result)that);
      return false;
    }

    public boolean equals(unlink_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("unlink_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class utime_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("utime_args");
    private static final TField PATH_FIELD_DESC = new TField("path", TType.STRING, (short)1);
    private static final TField ATIME_FIELD_DESC = new TField("atime", TType.I64, (short)2);
    private static final TField MTIME_FIELD_DESC = new TField("mtime", TType.I64, (short)3);

    /**
     * Path of the file or directory.
     */
    public String path;
    public static final int PATH = 1;
    /**
     * Access time in milliseconds since 1970-01-01 00:00 UTC
     */
    public long atime;
    public static final int ATIME = 2;
    /**
     * Modification time in milliseconds since 1970-01-01 00:00 UTC
     */
    public long mtime;
    public static final int MTIME = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean atime = false;
      public boolean mtime = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PATH, new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(ATIME, new FieldMetaData("atime", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(MTIME, new FieldMetaData("mtime", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(utime_args.class, metaDataMap);
    }

    public utime_args() {
    }

    public utime_args(
      String path,
      long atime,
      long mtime)
    {
      this();
      this.path = path;
      this.atime = atime;
      this.__isset.atime = true;
      this.mtime = mtime;
      this.__isset.mtime = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public utime_args(utime_args other) {
      if (other.isSetPath()) {
        this.path = other.path;
      }
      __isset.atime = other.__isset.atime;
      this.atime = other.atime;
      __isset.mtime = other.__isset.mtime;
      this.mtime = other.mtime;
    }

    @Override
    public utime_args clone() {
      return new utime_args(this);
    }

    /**
     * Path of the file or directory.
     */
    public String getPath() {
      return this.path;
    }

    /**
     * Path of the file or directory.
     */
    public void setPath(String path) {
      this.path = path;
    }

    public void unsetPath() {
      this.path = null;
    }

    // Returns true if field path is set (has been asigned a value) and false otherwise
    public boolean isSetPath() {
      return this.path != null;
    }

    public void setPathIsSet(boolean value) {
      if (!value) {
        this.path = null;
      }
    }

    /**
     * Access time in milliseconds since 1970-01-01 00:00 UTC
     */
    public long getAtime() {
      return this.atime;
    }

    /**
     * Access time in milliseconds since 1970-01-01 00:00 UTC
     */
    public void setAtime(long atime) {
      this.atime = atime;
      this.__isset.atime = true;
    }

    public void unsetAtime() {
      this.__isset.atime = false;
    }

    // Returns true if field atime is set (has been asigned a value) and false otherwise
    public boolean isSetAtime() {
      return this.__isset.atime;
    }

    public void setAtimeIsSet(boolean value) {
      this.__isset.atime = value;
    }

    /**
     * Modification time in milliseconds since 1970-01-01 00:00 UTC
     */
    public long getMtime() {
      return this.mtime;
    }

    /**
     * Modification time in milliseconds since 1970-01-01 00:00 UTC
     */
    public void setMtime(long mtime) {
      this.mtime = mtime;
      this.__isset.mtime = true;
    }

    public void unsetMtime() {
      this.__isset.mtime = false;
    }

    // Returns true if field mtime is set (has been asigned a value) and false otherwise
    public boolean isSetMtime() {
      return this.__isset.mtime;
    }

    public void setMtimeIsSet(boolean value) {
      this.__isset.mtime = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PATH:
        if (value == null) {
          unsetPath();
        } else {
          setPath((String)value);
        }
        break;

      case ATIME:
        if (value == null) {
          unsetAtime();
        } else {
          setAtime((Long)value);
        }
        break;

      case MTIME:
        if (value == null) {
          unsetMtime();
        } else {
          setMtime((Long)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PATH:
        return getPath();

      case ATIME:
        return new Long(getAtime());

      case MTIME:
        return new Long(getMtime());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PATH:
        return isSetPath();
      case ATIME:
        return isSetAtime();
      case MTIME:
        return isSetMtime();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof utime_args)
        return this.equals((utime_args)that);
      return false;
    }

    public boolean equals(utime_args that) {
      if (that == null)
        return false;

      boolean this_present_path = true && this.isSetPath();
      boolean that_present_path = true && that.isSetPath();
      if (this_present_path || that_present_path) {
        if (!(this_present_path && that_present_path))
          return false;
        if (!this.path.equals(that.path))
          return false;
      }

      boolean this_present_atime = true;
      boolean that_present_atime = true;
      if (this_present_atime || that_present_atime) {
        if (!(this_present_atime && that_present_atime))
          return false;
        if (this.atime != that.atime)
          return false;
      }

      boolean this_present_mtime = true;
      boolean that_present_mtime = true;
      if (this_present_mtime || that_present_mtime) {
        if (!(this_present_mtime && that_present_mtime))
          return false;
        if (this.mtime != that.mtime)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PATH:
            if (field.type == TType.STRING) {
              this.path = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ATIME:
            if (field.type == TType.I64) {
              this.atime = iprot.readI64();
              this.__isset.atime = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case MTIME:
            if (field.type == TType.I64) {
              this.mtime = iprot.readI64();
              this.__isset.mtime = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.path != null) {
        oprot.writeFieldBegin(PATH_FIELD_DESC);
        oprot.writeString(this.path);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(ATIME_FIELD_DESC);
      oprot.writeI64(this.atime);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MTIME_FIELD_DESC);
      oprot.writeI64(this.mtime);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("utime_args(");
      boolean first = true;

      sb.append("path:");
      if (this.path == null) {
        sb.append("null");
      } else {
        sb.append(this.path);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("atime:");
      sb.append(this.atime);
      first = false;
      if (!first) sb.append(", ");
      sb.append("mtime:");
      sb.append(this.mtime);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class utime_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("utime_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public IOException err;
    public static final int ERR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(utime_result.class, metaDataMap);
    }

    public utime_result() {
    }

    public utime_result(
      IOException err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public utime_result(utime_result other) {
      if (other.isSetErr()) {
        this.err = new IOException(other.err);
      }
    }

    @Override
    public utime_result clone() {
      return new utime_result(this);
    }

    public IOException getErr() {
      return this.err;
    }

    public void setErr(IOException err) {
      this.err = err;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((IOException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof utime_result)
        return this.equals((utime_result)that);
      return false;
    }

    public boolean equals(utime_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new IOException();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("utime_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class datanodeUp_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("datanodeUp_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField THRIFT_PORT_FIELD_DESC = new TField("thriftPort", TType.I32, (short)2);

    /**
     * <host name>:<port number> of the datanode
     */
    public String name;
    public static final int NAME = 1;
    /**
     * Thrift port of the datanode
     */
    public int thriftPort;
    public static final int THRIFTPORT = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean thriftPort = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(THRIFTPORT, new FieldMetaData("thriftPort", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(datanodeUp_args.class, metaDataMap);
    }

    public datanodeUp_args() {
    }

    public datanodeUp_args(
      String name,
      int thriftPort)
    {
      this();
      this.name = name;
      this.thriftPort = thriftPort;
      this.__isset.thriftPort = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public datanodeUp_args(datanodeUp_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      __isset.thriftPort = other.__isset.thriftPort;
      this.thriftPort = other.thriftPort;
    }

    @Override
    public datanodeUp_args clone() {
      return new datanodeUp_args(this);
    }

    /**
     * <host name>:<port number> of the datanode
     */
    public String getName() {
      return this.name;
    }

    /**
     * <host name>:<port number> of the datanode
     */
    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    /**
     * Thrift port of the datanode
     */
    public int getThriftPort() {
      return this.thriftPort;
    }

    /**
     * Thrift port of the datanode
     */
    public void setThriftPort(int thriftPort) {
      this.thriftPort = thriftPort;
      this.__isset.thriftPort = true;
    }

    public void unsetThriftPort() {
      this.__isset.thriftPort = false;
    }

    // Returns true if field thriftPort is set (has been asigned a value) and false otherwise
    public boolean isSetThriftPort() {
      return this.__isset.thriftPort;
    }

    public void setThriftPortIsSet(boolean value) {
      this.__isset.thriftPort = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case THRIFTPORT:
        if (value == null) {
          unsetThriftPort();
        } else {
          setThriftPort((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case THRIFTPORT:
        return new Integer(getThriftPort());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case THRIFTPORT:
        return isSetThriftPort();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof datanodeUp_args)
        return this.equals((datanodeUp_args)that);
      return false;
    }

    public boolean equals(datanodeUp_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_thriftPort = true;
      boolean that_present_thriftPort = true;
      if (this_present_thriftPort || that_present_thriftPort) {
        if (!(this_present_thriftPort && that_present_thriftPort))
          return false;
        if (this.thriftPort != that.thriftPort)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case THRIFTPORT:
            if (field.type == TType.I32) {
              this.thriftPort = iprot.readI32();
              this.__isset.thriftPort = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(THRIFT_PORT_FIELD_DESC);
      oprot.writeI32(this.thriftPort);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("datanodeUp_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("thriftPort:");
      sb.append(this.thriftPort);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class datanodeUp_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("datanodeUp_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(datanodeUp_result.class, metaDataMap);
    }

    public datanodeUp_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public datanodeUp_result(datanodeUp_result other) {
    }

    @Override
    public datanodeUp_result clone() {
      return new datanodeUp_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof datanodeUp_result)
        return this.equals((datanodeUp_result)that);
      return false;
    }

    public boolean equals(datanodeUp_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("datanodeUp_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class datanodeDown_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("datanodeDown_args");
    private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
    private static final TField THRIFT_PORT_FIELD_DESC = new TField("thriftPort", TType.I32, (short)2);

    /**
     * <host name>:<port number> of the datanode
     */
    public String name;
    public static final int NAME = 1;
    /**
     * Thrift port of the datanode
     */
    public int thriftPort;
    public static final int THRIFTPORT = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean thriftPort = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NAME, new FieldMetaData("name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(THRIFTPORT, new FieldMetaData("thriftPort", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(datanodeDown_args.class, metaDataMap);
    }

    public datanodeDown_args() {
    }

    public datanodeDown_args(
      String name,
      int thriftPort)
    {
      this();
      this.name = name;
      this.thriftPort = thriftPort;
      this.__isset.thriftPort = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public datanodeDown_args(datanodeDown_args other) {
      if (other.isSetName()) {
        this.name = other.name;
      }
      __isset.thriftPort = other.__isset.thriftPort;
      this.thriftPort = other.thriftPort;
    }

    @Override
    public datanodeDown_args clone() {
      return new datanodeDown_args(this);
    }

    /**
     * <host name>:<port number> of the datanode
     */
    public String getName() {
      return this.name;
    }

    /**
     * <host name>:<port number> of the datanode
     */
    public void setName(String name) {
      this.name = name;
    }

    public void unsetName() {
      this.name = null;
    }

    // Returns true if field name is set (has been asigned a value) and false otherwise
    public boolean isSetName() {
      return this.name != null;
    }

    public void setNameIsSet(boolean value) {
      if (!value) {
        this.name = null;
      }
    }

    /**
     * Thrift port of the datanode
     */
    public int getThriftPort() {
      return this.thriftPort;
    }

    /**
     * Thrift port of the datanode
     */
    public void setThriftPort(int thriftPort) {
      this.thriftPort = thriftPort;
      this.__isset.thriftPort = true;
    }

    public void unsetThriftPort() {
      this.__isset.thriftPort = false;
    }

    // Returns true if field thriftPort is set (has been asigned a value) and false otherwise
    public boolean isSetThriftPort() {
      return this.__isset.thriftPort;
    }

    public void setThriftPortIsSet(boolean value) {
      this.__isset.thriftPort = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NAME:
        if (value == null) {
          unsetName();
        } else {
          setName((String)value);
        }
        break;

      case THRIFTPORT:
        if (value == null) {
          unsetThriftPort();
        } else {
          setThriftPort((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NAME:
        return getName();

      case THRIFTPORT:
        return new Integer(getThriftPort());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NAME:
        return isSetName();
      case THRIFTPORT:
        return isSetThriftPort();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof datanodeDown_args)
        return this.equals((datanodeDown_args)that);
      return false;
    }

    public boolean equals(datanodeDown_args that) {
      if (that == null)
        return false;

      boolean this_present_name = true && this.isSetName();
      boolean that_present_name = true && that.isSetName();
      if (this_present_name || that_present_name) {
        if (!(this_present_name && that_present_name))
          return false;
        if (!this.name.equals(that.name))
          return false;
      }

      boolean this_present_thriftPort = true;
      boolean that_present_thriftPort = true;
      if (this_present_thriftPort || that_present_thriftPort) {
        if (!(this_present_thriftPort && that_present_thriftPort))
          return false;
        if (this.thriftPort != that.thriftPort)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NAME:
            if (field.type == TType.STRING) {
              this.name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case THRIFTPORT:
            if (field.type == TType.I32) {
              this.thriftPort = iprot.readI32();
              this.__isset.thriftPort = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.name != null) {
        oprot.writeFieldBegin(NAME_FIELD_DESC);
        oprot.writeString(this.name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(THRIFT_PORT_FIELD_DESC);
      oprot.writeI32(this.thriftPort);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("datanodeDown_args(");
      boolean first = true;

      sb.append("name:");
      if (this.name == null) {
        sb.append("null");
      } else {
        sb.append(this.name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("thriftPort:");
      sb.append(this.thriftPort);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class datanodeDown_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("datanodeDown_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(datanodeDown_result.class, metaDataMap);
    }

    public datanodeDown_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public datanodeDown_result(datanodeDown_result other) {
    }

    @Override
    public datanodeDown_result clone() {
      return new datanodeDown_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof datanodeDown_result)
        return this.equals((datanodeDown_result)that);
      return false;
    }

    public boolean equals(datanodeDown_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("datanodeDown_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
