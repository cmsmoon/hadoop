<?php
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
include_once $GLOBALS['THRIFT_ROOT'].'/Thrift.php';

include_once $GLOBALS['THRIFT_ROOT'].'/packages/hdfs/hdfs_types.php';
include_once $GLOBALS['THRIFT_ROOT'].'/packages/hdfs/HadoopServiceBase.php';

interface NamenodeIf extends HadoopServiceBaseIf {
  public function chmod($ctx, $path, $perms);
  public function chown($ctx, $path, $owner, $group);
  public function df($ctx);
  public function enterSafeMode($ctx);
  public function getBlocks($ctx, $path, $offset, $length);
  public function getDatanodeReport($ctx, $type);
  public function getHealthReport($ctx);
  public function getPreferredBlockSize($ctx, $path);
  public function isInSafeMode($ctx);
  public function leaveSafeMode($ctx);
  public function ls($ctx, $path);
  public function mkdirhier($ctx, $path, $perms);
  public function refreshNodes($ctx);
  public function rename($ctx, $path, $newPath);
  public function reportBadBlocks($ctx, $blocks);
  public function stat($ctx, $path);
  public function setQuota($ctx, $path, $namespaceQuota, $diskspaceQuota);
  public function setReplication($ctx, $path, $replication);
  public function unlink($ctx, $path, $recursive);
  public function utime($ctx, $path, $atime, $mtime);
  public function datanodeUp($name, $storage, $thriftPort);
  public function datanodeDown($name, $storage, $thriftPort);
}

class NamenodeClient extends HadoopServiceBaseClient implements NamenodeIf {
  public function __construct($input, $output=null) {
    parent::__construct($input, $output);
  }

  public function chmod($ctx, $path, $perms)
  {
    $this->send_chmod($ctx, $path, $perms);
    $this->recv_chmod();
  }

  public function send_chmod($ctx, $path, $perms)
  {
    $args = new hadoop_api_Namenode_chmod_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $args->perms = $perms;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'chmod', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('chmod', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_chmod()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_chmod_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_chmod_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    return;
  }

  public function chown($ctx, $path, $owner, $group)
  {
    $this->send_chown($ctx, $path, $owner, $group);
    $this->recv_chown();
  }

  public function send_chown($ctx, $path, $owner, $group)
  {
    $args = new hadoop_api_Namenode_chown_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $args->owner = $owner;
    $args->group = $group;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'chown', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('chown', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_chown()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_chown_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_chown_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    return;
  }

  public function df($ctx)
  {
    $this->send_df($ctx);
    return $this->recv_df();
  }

  public function send_df($ctx)
  {
    $args = new hadoop_api_Namenode_df_args();
    $args->ctx = $ctx;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'df', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('df', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_df()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_df_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_df_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("df failed: unknown result");
  }

  public function enterSafeMode($ctx)
  {
    $this->send_enterSafeMode($ctx);
    $this->recv_enterSafeMode();
  }

  public function send_enterSafeMode($ctx)
  {
    $args = new hadoop_api_Namenode_enterSafeMode_args();
    $args->ctx = $ctx;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'enterSafeMode', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('enterSafeMode', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_enterSafeMode()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_enterSafeMode_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_enterSafeMode_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    return;
  }

  public function getBlocks($ctx, $path, $offset, $length)
  {
    $this->send_getBlocks($ctx, $path, $offset, $length);
    return $this->recv_getBlocks();
  }

  public function send_getBlocks($ctx, $path, $offset, $length)
  {
    $args = new hadoop_api_Namenode_getBlocks_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $args->offset = $offset;
    $args->length = $length;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getBlocks', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getBlocks', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getBlocks()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_getBlocks_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_getBlocks_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("getBlocks failed: unknown result");
  }

  public function getDatanodeReport($ctx, $type)
  {
    $this->send_getDatanodeReport($ctx, $type);
    return $this->recv_getDatanodeReport();
  }

  public function send_getDatanodeReport($ctx, $type)
  {
    $args = new hadoop_api_Namenode_getDatanodeReport_args();
    $args->ctx = $ctx;
    $args->type = $type;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getDatanodeReport', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getDatanodeReport', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getDatanodeReport()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_getDatanodeReport_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_getDatanodeReport_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("getDatanodeReport failed: unknown result");
  }

  public function getHealthReport($ctx)
  {
    $this->send_getHealthReport($ctx);
    return $this->recv_getHealthReport();
  }

  public function send_getHealthReport($ctx)
  {
    $args = new hadoop_api_Namenode_getHealthReport_args();
    $args->ctx = $ctx;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getHealthReport', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getHealthReport', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getHealthReport()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_getHealthReport_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_getHealthReport_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("getHealthReport failed: unknown result");
  }

  public function getPreferredBlockSize($ctx, $path)
  {
    $this->send_getPreferredBlockSize($ctx, $path);
    return $this->recv_getPreferredBlockSize();
  }

  public function send_getPreferredBlockSize($ctx, $path)
  {
    $args = new hadoop_api_Namenode_getPreferredBlockSize_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getPreferredBlockSize', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getPreferredBlockSize', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getPreferredBlockSize()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_getPreferredBlockSize_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_getPreferredBlockSize_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("getPreferredBlockSize failed: unknown result");
  }

  public function isInSafeMode($ctx)
  {
    $this->send_isInSafeMode($ctx);
    return $this->recv_isInSafeMode();
  }

  public function send_isInSafeMode($ctx)
  {
    $args = new hadoop_api_Namenode_isInSafeMode_args();
    $args->ctx = $ctx;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'isInSafeMode', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('isInSafeMode', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_isInSafeMode()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_isInSafeMode_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_isInSafeMode_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("isInSafeMode failed: unknown result");
  }

  public function leaveSafeMode($ctx)
  {
    $this->send_leaveSafeMode($ctx);
    $this->recv_leaveSafeMode();
  }

  public function send_leaveSafeMode($ctx)
  {
    $args = new hadoop_api_Namenode_leaveSafeMode_args();
    $args->ctx = $ctx;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'leaveSafeMode', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('leaveSafeMode', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_leaveSafeMode()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_leaveSafeMode_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_leaveSafeMode_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    return;
  }

  public function ls($ctx, $path)
  {
    $this->send_ls($ctx, $path);
    return $this->recv_ls();
  }

  public function send_ls($ctx, $path)
  {
    $args = new hadoop_api_Namenode_ls_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'ls', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('ls', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_ls()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_ls_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_ls_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("ls failed: unknown result");
  }

  public function mkdirhier($ctx, $path, $perms)
  {
    $this->send_mkdirhier($ctx, $path, $perms);
    return $this->recv_mkdirhier();
  }

  public function send_mkdirhier($ctx, $path, $perms)
  {
    $args = new hadoop_api_Namenode_mkdirhier_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $args->perms = $perms;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'mkdirhier', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('mkdirhier', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_mkdirhier()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_mkdirhier_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_mkdirhier_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("mkdirhier failed: unknown result");
  }

  public function refreshNodes($ctx)
  {
    $this->send_refreshNodes($ctx);
    $this->recv_refreshNodes();
  }

  public function send_refreshNodes($ctx)
  {
    $args = new hadoop_api_Namenode_refreshNodes_args();
    $args->ctx = $ctx;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'refreshNodes', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('refreshNodes', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_refreshNodes()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_refreshNodes_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_refreshNodes_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    return;
  }

  public function rename($ctx, $path, $newPath)
  {
    $this->send_rename($ctx, $path, $newPath);
    return $this->recv_rename();
  }

  public function send_rename($ctx, $path, $newPath)
  {
    $args = new hadoop_api_Namenode_rename_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $args->newPath = $newPath;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'rename', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('rename', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_rename()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_rename_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_rename_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("rename failed: unknown result");
  }

  public function reportBadBlocks($ctx, $blocks)
  {
    $this->send_reportBadBlocks($ctx, $blocks);
    $this->recv_reportBadBlocks();
  }

  public function send_reportBadBlocks($ctx, $blocks)
  {
    $args = new hadoop_api_Namenode_reportBadBlocks_args();
    $args->ctx = $ctx;
    $args->blocks = $blocks;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'reportBadBlocks', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('reportBadBlocks', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_reportBadBlocks()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_reportBadBlocks_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_reportBadBlocks_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    return;
  }

  public function stat($ctx, $path)
  {
    $this->send_stat($ctx, $path);
    return $this->recv_stat();
  }

  public function send_stat($ctx, $path)
  {
    $args = new hadoop_api_Namenode_stat_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'stat', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('stat', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_stat()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_stat_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_stat_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("stat failed: unknown result");
  }

  public function setQuota($ctx, $path, $namespaceQuota, $diskspaceQuota)
  {
    $this->send_setQuota($ctx, $path, $namespaceQuota, $diskspaceQuota);
    $this->recv_setQuota();
  }

  public function send_setQuota($ctx, $path, $namespaceQuota, $diskspaceQuota)
  {
    $args = new hadoop_api_Namenode_setQuota_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $args->namespaceQuota = $namespaceQuota;
    $args->diskspaceQuota = $diskspaceQuota;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'setQuota', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('setQuota', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_setQuota()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_setQuota_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_setQuota_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    return;
  }

  public function setReplication($ctx, $path, $replication)
  {
    $this->send_setReplication($ctx, $path, $replication);
    return $this->recv_setReplication();
  }

  public function send_setReplication($ctx, $path, $replication)
  {
    $args = new hadoop_api_Namenode_setReplication_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $args->replication = $replication;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'setReplication', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('setReplication', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_setReplication()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_setReplication_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_setReplication_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("setReplication failed: unknown result");
  }

  public function unlink($ctx, $path, $recursive)
  {
    $this->send_unlink($ctx, $path, $recursive);
    return $this->recv_unlink();
  }

  public function send_unlink($ctx, $path, $recursive)
  {
    $args = new hadoop_api_Namenode_unlink_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $args->recursive = $recursive;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'unlink', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('unlink', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_unlink()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_unlink_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_unlink_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    throw new Exception("unlink failed: unknown result");
  }

  public function utime($ctx, $path, $atime, $mtime)
  {
    $this->send_utime($ctx, $path, $atime, $mtime);
    $this->recv_utime();
  }

  public function send_utime($ctx, $path, $atime, $mtime)
  {
    $args = new hadoop_api_Namenode_utime_args();
    $args->ctx = $ctx;
    $args->path = $path;
    $args->atime = $atime;
    $args->mtime = $mtime;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'utime', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('utime', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_utime()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_utime_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_utime_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->err !== null) {
      throw $result->err;
    }
    return;
  }

  public function datanodeUp($name, $storage, $thriftPort)
  {
    $this->send_datanodeUp($name, $storage, $thriftPort);
    $this->recv_datanodeUp();
  }

  public function send_datanodeUp($name, $storage, $thriftPort)
  {
    $args = new hadoop_api_Namenode_datanodeUp_args();
    $args->name = $name;
    $args->storage = $storage;
    $args->thriftPort = $thriftPort;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'datanodeUp', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('datanodeUp', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_datanodeUp()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_datanodeUp_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_datanodeUp_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    return;
  }

  public function datanodeDown($name, $storage, $thriftPort)
  {
    $this->send_datanodeDown($name, $storage, $thriftPort);
    $this->recv_datanodeDown();
  }

  public function send_datanodeDown($name, $storage, $thriftPort)
  {
    $args = new hadoop_api_Namenode_datanodeDown_args();
    $args->name = $name;
    $args->storage = $storage;
    $args->thriftPort = $thriftPort;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'datanodeDown', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('datanodeDown', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_datanodeDown()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'hadoop_api_Namenode_datanodeDown_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new hadoop_api_Namenode_datanodeDown_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    return;
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class hadoop_api_Namenode_chmod_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;
  public $perms = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'perms',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['perms'])) {
        $this->perms = $vals['perms'];
      }
    }
  }

  public function getName() {
    return 'Namenode_chmod_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->perms);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_chmod_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->perms !== null) {
      $xfer += $output->writeFieldBegin('perms', TType::I16, 2);
      $xfer += $output->writeI16($this->perms);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_chmod_result {
  static $_TSPEC;

  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_chmod_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_chmod_result');
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_chown_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;
  public $owner = null;
  public $group = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'owner',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'group',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['owner'])) {
        $this->owner = $vals['owner'];
      }
      if (isset($vals['group'])) {
        $this->group = $vals['group'];
      }
    }
  }

  public function getName() {
    return 'Namenode_chown_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->owner);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->group);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_chown_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->owner !== null) {
      $xfer += $output->writeFieldBegin('owner', TType::STRING, 2);
      $xfer += $output->writeString($this->owner);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->group !== null) {
      $xfer += $output->writeFieldBegin('group', TType::STRING, 3);
      $xfer += $output->writeString($this->group);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_chown_result {
  static $_TSPEC;

  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_chown_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_chown_result');
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_df_args {
  static $_TSPEC;

  public $ctx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
    }
  }

  public function getName() {
    return 'Namenode_df_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_df_args');
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_df_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_df_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size30 = 0;
            $_etype33 = 0;
            $xfer += $input->readListBegin($_etype33, $_size30);
            for ($_i34 = 0; $_i34 < $_size30; ++$_i34)
            {
              $elem35 = null;
              $xfer += $input->readI64($elem35);
              $this->success []= $elem35;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_df_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::I64, count($this->success));
        {
          foreach ($this->success as $iter36)
          {
            $xfer += $output->writeI64($iter36);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_enterSafeMode_args {
  static $_TSPEC;

  public $ctx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
    }
  }

  public function getName() {
    return 'Namenode_enterSafeMode_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_enterSafeMode_args');
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_enterSafeMode_result {
  static $_TSPEC;

  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_enterSafeMode_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_enterSafeMode_result');
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_getBlocks_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;
  public $offset = null;
  public $length = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'offset',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'length',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['offset'])) {
        $this->offset = $vals['offset'];
      }
      if (isset($vals['length'])) {
        $this->length = $vals['length'];
      }
    }
  }

  public function getName() {
    return 'Namenode_getBlocks_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->offset);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->length);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_getBlocks_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->offset !== null) {
      $xfer += $output->writeFieldBegin('offset', TType::I64, 2);
      $xfer += $output->writeI64($this->offset);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->length !== null) {
      $xfer += $output->writeFieldBegin('length', TType::I64, 3);
      $xfer += $output->writeI64($this->length);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_getBlocks_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'hadoop_api_Block',
            ),
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_getBlocks_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size37 = 0;
            $_etype40 = 0;
            $xfer += $input->readListBegin($_etype40, $_size37);
            for ($_i41 = 0; $_i41 < $_size37; ++$_i41)
            {
              $elem42 = null;
              $elem42 = new hadoop_api_Block();
              $xfer += $elem42->read($input);
              $this->success []= $elem42;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_getBlocks_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter43)
          {
            $xfer += $iter43->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_getDatanodeReport_args {
  static $_TSPEC;

  public $ctx = null;
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'Namenode_getDatanodeReport_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_getDatanodeReport_args');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_getDatanodeReport_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'hadoop_api_DatanodeInfo',
            ),
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_getDatanodeReport_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size44 = 0;
            $_etype47 = 0;
            $xfer += $input->readListBegin($_etype47, $_size44);
            for ($_i48 = 0; $_i48 < $_size44; ++$_i48)
            {
              $elem49 = null;
              $elem49 = new hadoop_api_DatanodeInfo();
              $xfer += $elem49->read($input);
              $this->success []= $elem49;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_getDatanodeReport_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter50)
          {
            $xfer += $iter50->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_getHealthReport_args {
  static $_TSPEC;

  public $ctx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
    }
  }

  public function getName() {
    return 'Namenode_getHealthReport_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_getHealthReport_args');
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_getHealthReport_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_DFSHealthReport',
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_getHealthReport_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new hadoop_api_DFSHealthReport();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_getHealthReport_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_getPreferredBlockSize_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
    }
  }

  public function getName() {
    return 'Namenode_getPreferredBlockSize_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_getPreferredBlockSize_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_getPreferredBlockSize_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I64,
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_getPreferredBlockSize_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_getPreferredBlockSize_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I64, 0);
      $xfer += $output->writeI64($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_isInSafeMode_args {
  static $_TSPEC;

  public $ctx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
    }
  }

  public function getName() {
    return 'Namenode_isInSafeMode_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_isInSafeMode_args');
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_isInSafeMode_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_isInSafeMode_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_isInSafeMode_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_leaveSafeMode_args {
  static $_TSPEC;

  public $ctx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
    }
  }

  public function getName() {
    return 'Namenode_leaveSafeMode_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_leaveSafeMode_args');
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_leaveSafeMode_result {
  static $_TSPEC;

  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_leaveSafeMode_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_leaveSafeMode_result');
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_ls_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
    }
  }

  public function getName() {
    return 'Namenode_ls_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_ls_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_ls_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'hadoop_api_Stat',
            ),
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_ls_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size51 = 0;
            $_etype54 = 0;
            $xfer += $input->readListBegin($_etype54, $_size51);
            for ($_i55 = 0; $_i55 < $_size51; ++$_i55)
            {
              $elem56 = null;
              $elem56 = new hadoop_api_Stat();
              $xfer += $elem56->read($input);
              $this->success []= $elem56;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_ls_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter57)
          {
            $xfer += $iter57->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_mkdirhier_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;
  public $perms = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'perms',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['perms'])) {
        $this->perms = $vals['perms'];
      }
    }
  }

  public function getName() {
    return 'Namenode_mkdirhier_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->perms);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_mkdirhier_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->perms !== null) {
      $xfer += $output->writeFieldBegin('perms', TType::I16, 2);
      $xfer += $output->writeI16($this->perms);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_mkdirhier_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_mkdirhier_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_mkdirhier_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_refreshNodes_args {
  static $_TSPEC;

  public $ctx = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
    }
  }

  public function getName() {
    return 'Namenode_refreshNodes_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_refreshNodes_args');
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_refreshNodes_result {
  static $_TSPEC;

  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_refreshNodes_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_refreshNodes_result');
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_rename_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;
  public $newPath = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'newPath',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['newPath'])) {
        $this->newPath = $vals['newPath'];
      }
    }
  }

  public function getName() {
    return 'Namenode_rename_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->newPath);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_rename_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newPath !== null) {
      $xfer += $output->writeFieldBegin('newPath', TType::STRING, 2);
      $xfer += $output->writeString($this->newPath);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_rename_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_rename_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_rename_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_reportBadBlocks_args {
  static $_TSPEC;

  public $ctx = null;
  public $blocks = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'blocks',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'hadoop_api_Block',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['blocks'])) {
        $this->blocks = $vals['blocks'];
      }
    }
  }

  public function getName() {
    return 'Namenode_reportBadBlocks_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::LST) {
            $this->blocks = array();
            $_size58 = 0;
            $_etype61 = 0;
            $xfer += $input->readListBegin($_etype61, $_size58);
            for ($_i62 = 0; $_i62 < $_size58; ++$_i62)
            {
              $elem63 = null;
              $elem63 = new hadoop_api_Block();
              $xfer += $elem63->read($input);
              $this->blocks []= $elem63;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_reportBadBlocks_args');
    if ($this->blocks !== null) {
      if (!is_array($this->blocks)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('blocks', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->blocks));
        {
          foreach ($this->blocks as $iter64)
          {
            $xfer += $iter64->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_reportBadBlocks_result {
  static $_TSPEC;

  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_reportBadBlocks_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_reportBadBlocks_result');
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_stat_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
    }
  }

  public function getName() {
    return 'Namenode_stat_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_stat_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_stat_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_Stat',
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_stat_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new hadoop_api_Stat();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_stat_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_setQuota_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;
  public $namespaceQuota = null;
  public $diskspaceQuota = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'namespaceQuota',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'diskspaceQuota',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['namespaceQuota'])) {
        $this->namespaceQuota = $vals['namespaceQuota'];
      }
      if (isset($vals['diskspaceQuota'])) {
        $this->diskspaceQuota = $vals['diskspaceQuota'];
      }
    }
  }

  public function getName() {
    return 'Namenode_setQuota_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->namespaceQuota);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->diskspaceQuota);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_setQuota_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->namespaceQuota !== null) {
      $xfer += $output->writeFieldBegin('namespaceQuota', TType::I64, 2);
      $xfer += $output->writeI64($this->namespaceQuota);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->diskspaceQuota !== null) {
      $xfer += $output->writeFieldBegin('diskspaceQuota', TType::I64, 3);
      $xfer += $output->writeI64($this->diskspaceQuota);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_setQuota_result {
  static $_TSPEC;

  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_setQuota_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_setQuota_result');
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_setReplication_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;
  public $replication = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'replication',
          'type' => TType::I16,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['replication'])) {
        $this->replication = $vals['replication'];
      }
    }
  }

  public function getName() {
    return 'Namenode_setReplication_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->replication);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_setReplication_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replication !== null) {
      $xfer += $output->writeFieldBegin('replication', TType::I16, 2);
      $xfer += $output->writeI16($this->replication);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_setReplication_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_setReplication_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_setReplication_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_unlink_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;
  public $recursive = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'recursive',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['recursive'])) {
        $this->recursive = $vals['recursive'];
      }
    }
  }

  public function getName() {
    return 'Namenode_unlink_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->recursive);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_unlink_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->recursive !== null) {
      $xfer += $output->writeFieldBegin('recursive', TType::BOOL, 2);
      $xfer += $output->writeBool($this->recursive);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_unlink_result {
  static $_TSPEC;

  public $success = null;
  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_unlink_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_unlink_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_utime_args {
  static $_TSPEC;

  public $ctx = null;
  public $path = null;
  public $atime = null;
  public $mtime = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'ctx',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_RequestContext',
          ),
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'atime',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'mtime',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['ctx'])) {
        $this->ctx = $vals['ctx'];
      }
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['atime'])) {
        $this->atime = $vals['atime'];
      }
      if (isset($vals['mtime'])) {
        $this->mtime = $vals['mtime'];
      }
    }
  }

  public function getName() {
    return 'Namenode_utime_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->ctx = new hadoop_api_RequestContext();
            $xfer += $this->ctx->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->atime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->mtime);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_utime_args');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->atime !== null) {
      $xfer += $output->writeFieldBegin('atime', TType::I64, 2);
      $xfer += $output->writeI64($this->atime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mtime !== null) {
      $xfer += $output->writeFieldBegin('mtime', TType::I64, 3);
      $xfer += $output->writeI64($this->mtime);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ctx !== null) {
      if (!is_object($this->ctx)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ctx', TType::STRUCT, 10);
      $xfer += $this->ctx->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_utime_result {
  static $_TSPEC;

  public $err = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'err',
          'type' => TType::STRUCT,
          'class' => 'hadoop_api_IOException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['err'])) {
        $this->err = $vals['err'];
      }
    }
  }

  public function getName() {
    return 'Namenode_utime_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->err = new hadoop_api_IOException();
            $xfer += $this->err->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_utime_result');
    if ($this->err !== null) {
      $xfer += $output->writeFieldBegin('err', TType::STRUCT, 1);
      $xfer += $this->err->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_datanodeUp_args {
  static $_TSPEC;

  public $name = null;
  public $storage = null;
  public $thriftPort = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'storage',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'thriftPort',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['storage'])) {
        $this->storage = $vals['storage'];
      }
      if (isset($vals['thriftPort'])) {
        $this->thriftPort = $vals['thriftPort'];
      }
    }
  }

  public function getName() {
    return 'Namenode_datanodeUp_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->storage);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->thriftPort);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_datanodeUp_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->storage !== null) {
      $xfer += $output->writeFieldBegin('storage', TType::STRING, 2);
      $xfer += $output->writeString($this->storage);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->thriftPort !== null) {
      $xfer += $output->writeFieldBegin('thriftPort', TType::I32, 3);
      $xfer += $output->writeI32($this->thriftPort);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_datanodeUp_result {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Namenode_datanodeUp_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_datanodeUp_result');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_datanodeDown_args {
  static $_TSPEC;

  public $name = null;
  public $storage = null;
  public $thriftPort = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'storage',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'thriftPort',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['storage'])) {
        $this->storage = $vals['storage'];
      }
      if (isset($vals['thriftPort'])) {
        $this->thriftPort = $vals['thriftPort'];
      }
    }
  }

  public function getName() {
    return 'Namenode_datanodeDown_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->storage);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->thriftPort);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_datanodeDown_args');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->storage !== null) {
      $xfer += $output->writeFieldBegin('storage', TType::STRING, 2);
      $xfer += $output->writeString($this->storage);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->thriftPort !== null) {
      $xfer += $output->writeFieldBegin('thriftPort', TType::I32, 3);
      $xfer += $output->writeI32($this->thriftPort);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class hadoop_api_Namenode_datanodeDown_result {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Namenode_datanodeDown_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Namenode_datanodeDown_result');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

?>
